'*'需要理解的知识点，'#'不熟知识点

# 基本概念

## 发展历程

### 历史物理硬件发展

晶体管
电子管
集成电路

### 计算机系统组成

#### 硬件系统

计算机的物理组成设备，是计算机系统的基础

##### 主机

运算器、控制器、存储器、I/O设备

##### 外部设备

打印机、扫描仪

##### 通信设备

网卡、调制解调器

#### 软件系统

由一系列协同工作的软件和数据的集合

##### 系统软件

管理和控制计硬件和系统资源的软件

###### 例如

操作系统、编译器、驱动程序、数据库、数据库管理软件

##### 应用软件

用于完成用户的某个具体任务的软件，其依赖于系统软件的服务和支持。

###### 例如

办公软件、娱乐软件

### 摩尔定理

半导体技术进步规律，侧面揭示了信息技术进步的速度

### 两种体系结构

#### 冯诺依曼结构

以运算器为中心

##### 结构特点

由五大部件组成
地址和数据以同等地位存于存储器，可按地址访问
指令和数据用二进制表示
指令由操作码和地址码所组成
存储程序结构

##### 存储程序思想

将预先编写好的程序和所需数据加载到主存中，才可执行，一旦程序被执行，就无需操作人员的干预，计算机会自动逐条执行指令，直至程序结束。

按照此原理，计算机应具有的功能为：数据传输功能、数据处理功能、数据存储功能、操作控制功能、操作判断（分析）功能。

#### 现代计算机结构

以存储器为中心

#### 共同点

都由运算器、控制器、存储器、输入设备、输出设备组成



## 计算机常用的功能部件

### 存储器

由MAR、MDR、存储体和时序控制逻辑组成

#### 工作方式：

每个存储单元有唯一的地址对应。
按存储单元的地址进行存取，被称为按地址存取方式

#### 地址寄存器MAR

用于存储指令或数据的内存地址
在执行过程中，根据指令中包含的地址信息访问内存中的数据                 

MAR的位数表示存储单元的个数。且与PC长度相等。

#### 数据寄存器MDR

又称为通用寄存器，用于暂存数据或指令。

MDR的位数表示存储字长的大小（即每个存储单元的容量）。

##### 作用

提供一个快速的存储单元，在CPU中进行数据处理操作

**MAR和MDR，在现代计算机中被集成在CPU中，逻辑上属于主存**

#### 存储体

由许多存储单元组成。

##### 存储单元

每个存储单元包含若干个存储元件

**存储单元的操作数是指：对存储单元进行读取或写入操作时所使用的数据值**。

##### 存储元件

每个存储元件存储一位二进制代码。

存储单元中存储的**一串二进制代码**被称为**存储字**，**存储字的位数**称为**存储字长**。

#### 时序控制逻辑

##### 作用

它负责控制指令的执行顺序，以及控制数据在各个功能部件之间的传输和处理。

时序控制逻辑通常由时钟信号驱动，根据指令集的设计要求，产生不同的控制信号，实现对计算机系统各个功能模块的控制。

##### 组成

时序控制逻辑一般包括以下几个部分：

1. 状态机：负责计算机指令的执行和状态转移；
2. 指令译码器：将指令码转换为对应的操作；
3. 存储器控制器：管理存储器的读写操作；
4. I/O控制器：管理输入输出设备的操作；
5. 时序生成器：产生时序信号，控制各个模块的运行和操作。

时序控制逻辑是计算机系统中的重要组成部分，它的正确性和可靠性直接影响着整个系统的性能和稳定性。

##### 状态机

在计算机组成原理中，状态机是指一种**有限状态自动机**（Finite State Automaton，简称FSA），用于描述计算机系统中的时序控制电路。状态机通过状态的转移实现对系统的控制。

计算机系统中的状态机通常由两部分组成：状态寄存器和状态转移逻辑。状态寄存器用于存储当前系统状态，状态转移逻辑则根据当前状态和输入信号决定下一个状态。

在计算机系统中，状态机常常被用来实现复杂的控制逻辑，例如指令译码、流水线控制、中断处理等。

##### 时序控制器

时序控制器是计算机中的一种组件，用于控制计算机内部的操作时序。它是一个状态机，根据程序执行的需要，生成一系列的时序信号，用于控制计算机内部各个部件的工作。时序控制器通常包含一个时钟，用于产生计算机系统的基准时序，它还包括一些逻辑电路和计数器，用于根据指令序列生成相应的时序信号。



### 运算器

由ALU、各种通用寄存器、状态寄存器、控制逻辑组成

#### 算术逻辑单元（ALU）：

负责实现各种算术和逻辑运算，例如加法、减法、乘法、除法、与、或、非、异或等。

#### 累加寄存器（ACC）：

存放操作数和运算结果。

#### 乘商寄存器（MQ）：

用于存放乘法结果的时的低位，而ACC在乘法时用于保存乘法结果的高位。

#### 操作数寄存器（X）：

用于存放操作数。

#### 数据缓冲寄存器（DR）：

作为数据输入和输出的接口，将需要操作的数据从存储器读入，并将操作结果存回存储器中。

#### 状态寄存器（SR）：

存放运算器的状态标志，例如零标志、进位标志、溢出标志等。

#### 控制逻辑：

负责控制运算器的工作，例如指令译码、操作码识别、指令执行控制等。

#### 运算器常见的基本组成和操作分配

![image-20230530160604333](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230530160604333.png)

**ACC和X用于运算的输入，ACC和MQ也作为保存运算的结果。**

##### 乘法操作

![image-20230530161122137](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230530161122137.png)

### 控制器

指令执行的先后顺序由控制器控制。由PC、IR、译码器和控制存储器组成。

#### 程序计数器(PC)：

用于存放下一条指令的地址。

#### 指令寄存器(IR)：

用于存放当前正在执行的指令。

#### 译码器：

用于**将指令进行解码，并发出控制信号**，控制CPU的各个部件执行相应的操作。

#### 控制存储器：

用于存放控制器的微程序，也就是**指令执行的具体流程**，通过译码器发出的控制信号来执行相应的操作。

#### 处理器如何区分取指令还是数据

**处理器根据指令周期的不同阶段来区分取指令还是数据。**在每个时钟周期内，处理器会完成一些特定的操作，并根据需要在总线上读取指令或数据。

指令周期通常被分为几个阶段，包括<u>取指令、译码、执行、访存和写回</u>等。

在取指令阶段，处理器从内存中读取指令，将其存储在指令寄存器中，然后进行解码以确定指令的操作类型和操作数。

在执行阶段，处理器执行指令的实际操作，通常包括算术运算、逻辑运算、移位和存储等。

在访存阶段，处理器根据需要读取或写入数据存储器中的数据，以及更新指针或标志寄存器等。

在写回阶段，处理器将执行结果写回到寄存器文件或内存中。

通过精确控制这些阶段的时序和操作，处理器可以实现高效的计算和控制任务。

## 冯·诺依曼计算机系统#

![image-20230503105849851](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230503105849851.png)

虚线：控制流，实线：数据流。

冯诺依曼机的工作原理是 ：控制流驱动，按地址访问并顺序执行指令。



## 现代计算机组成框图

![image-20230530150226881](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230530150226881.png)

**修改：ALU为运算器，CU为空控制器。**

单箭头实线：控制流，双箭头：数据流，虚线箭头：反馈线。

## 计算机体系的层次结构

### M0层

是计算机系统五层层次结构中最底层的微程序机器（microprogrammed machine），也称为微程序控制器。在M0层次，计算机系统被实现为硬件的集合，包括寄存器、数据通路和微程序存储器等。微程序机器使用微指令的形式来实现指令的执行。也就是说**硬件真正执行的指令。**

微指令是一些微小的控制信号，用于执行指令中的操作。M0层次中的微程序控制器被用来解码指令，发出微指令并控制计算机硬件的执行。由微程序解释微指令系统。

### M1层

指令系统层，主要包括指令系统的设计、指令格式、寻址方式等，是机器语言与汇编语言的抽象表示。由机器硬件直接执行微指令。

### M2层

操作系统层，主要负责管理计算机的硬件和软件资源，包括进程管理、内存管理、文件管理、设备管理等。提供了汇编语言和高级语言的使用和实现过程中所需的基本操作。

### M3层

汇编语言层，为用户提供一种符号化语言，解释可编写汇编语言源程序，由**汇编程序**支持和执行。

### M4层

高级语言层，是一种面向问题解决的编程语言，具有语言简洁、易读易写、提高开发效率等特点。常见的高级语言有C、C++、Java、Python等。**由编译或解释程序进行编译（全部翻译完成后，生成可执行文件）或解释（边解释边执行）。**

### 体现

**下层是上层的基础，上层是下层的扩展。下层对上层的指令进行解释——即下层需要进行什么操作。**

![image-20230503151523202](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230503151523202.png)

#### 计算机体系结构

其更多的在于如何设计硬件与软件之间的接口，**如何使用指令**。

程序员所见到的计算机系统的属性（指令系统、数据类型、寻址技术、I/O机理），概念性的结构与功能特性。

#### 计算机组成原理

其更多的在于用硬件实现所定义的接口，**如何（用硬件）实现指令**。

实现计算机系统结构所体现的属性。

## 计算机中的语法和语义：

语法：外表是什么样——外部结构

语义：所表达的含义——内部实现

## 计算机系统的工作原理

### 存储程序的工作方式

控制流驱动，按地址访问指令，且顺序执行

### 编译系统

分四个阶段：预处理阶段 —— 编译阶段 ——汇编阶段 —— 链接阶段

#### 预处理阶段

由预处理器主导，将代码中那些引用类型的代码替换为目标代码，在C语言中主要是将宏处理（比如将宏代码，用起目标文件或代码块插入源代码中的所需位置，完成后，会生成后缀名为“.i”的**相比于源文件是一个扩展的文本文件**。

#### 编译阶段

由编译器主导，将上一阶段的“.i”文本文件**翻译**成汇编程序（也是文本文件）：后缀为".s"

#### 汇编阶段

将上一阶段的汇编程序，**翻译**成对应的机器语言指令(二进制文件“.o”)，并打包成“可重定位目标程序”格式，传递给下一个阶段。

#### 链接阶段

将上一阶段传递的二进制文件，且将它所需的标准库的函数以及其他，所对应的提前预编译好的二进制文件，通过**链接器**进行合并，生成可执行文件“.exe"。

### 程序指令过程的描述

程序的执行过程就是数据在CPU、主存储器和I/O设备之间流动的过程。

而数据的流动都是通过总线、I/O接口等进行的。

### 指令执行过程的描述*

分为三段：取指令(PC)->分析指令(IR)->执行指令(CU)

![image-20230503141350820](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230503141350820.png)

`OP`指的是指令的操作码（Opcode），`Ad`是指指令的地址码。

`操作码`是一条计算机指令中用于指定指令操作类型的部分，通常占据了指令的高位二进制位。

M(MAR)->MDR是指，将MAR中存储的地址，通过地址总线，访问指向的存储单元，将存储单元保存的数据通过数据总线传输到MDR中。

**M是指存储体中的某个存储单元，通常来说是IR中指令的地址码**。



## 计算机的性能指标 

### 机器字长

计算机一次性处理数据的二进制位数，也就是存储字长

机器字长与CPU内部的寄存器有关，<u>对机器字长的改变将直接影响运算器、数据总线以及存储字长的位数。</u>

#### 字

被设计用于传输信息的定长字节块（也就是1个字=n个字节,n=2^存储字长/8bit）。

字是计算机系统中**数据处理的基本单位**。它表示在一次操作中处理的二进制数据的位数。字的位数可以是不同的，<font color=blue>常见的字长有8位、16位、32位、64位等</font>。字长决定了CPU的数据总线宽度和寄存器的大小。

### 主存容量

#### 计算：

$存储单元个数\times存储字长=字数 \times字长=2^{MAR位数} \times MDR (bit)$

$=2^{MAR位数} \times MDR/ 8 (Byte)$

#### MAR

反映了存储单元的个数，即地址个数、或字数，​或者说有多少地址空间。

##### 存储单元：

由操作码和地址码组成。

#### MDR

反映了存储单元的字长

从里到内：

存储体-->存储单元-->存储元

#### *存储字、存储字长

存储字：即一个存储单元存储的一串二进制位数。也就是存储单元。

存储字长：即一个存储单元存储的一串二进制数据的位数。

存储字数：存储器存储单元共的个数（地址空间的大小）。

存储容量：存储字数*存储字长

## 运算速度

MIPS、CPI、FLOPS。

## 整体性能

### 静态测试

#### 吞吐量

单位时间内能处理的任务数，是计算机性能的综合评判选择

#### 响应时间

系统完成某任务所需的总时间

#### 数据通路带宽

常指外部的数据总线单位时间内并行传输信息的位数,(与CPU内部的数据总线不同).



### 动态测试

#### 基准程序

专门用于性能评价的一组程序，反映机器运行实际负载时的性能。

但其性能评价是不能完全有客观性的，因为其核心代码可被程序员单独优化，以至于结果不具有真实情况

比如：跑分软件



## CPU性能

### 主频

**单位时间内产生的脉冲信号个数**，也叫<u>时钟频率</u>，机器内部主时钟的频率

#### 计算：

1/CPU时钟周期

通常：1Hz=表示一秒执行一次，1GHz=10^9Hz，1s = 10^3 ms = 10^6 μs		

CPU速度提高，不代表其执行指令的速度按同等比例相较以前减少
如：CPU速度提高50%，原指令CPU执行时间为90，那现在需要执行时间为90/1.5=70

### CPU时钟周期

CPU内部进行一次操作所需要的时间，**一个脉冲执行的时间长度**

是CPU中最基本的操作单位，最小时间单位

![image-20230504131726069](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230504131726069.png)

### 时钟周期数

指CPU完成某条指令所需的时钟周期个数

### CPI（指令的平均时钟周期数）

指某程序或该机器指令集中**每条指令执行所需的平均时钟周期数**

#### 计算：

CPU时钟周期数 / 指令总数

与时钟周期数、系统结构、指令集、计算机组织有关

### CPU执行时间

运行一个程序所需花费的时间

#### 计算：

时钟周期数 / 时钟频率=时钟周期数 x 时钟周期=**(指令数 x CPI) / 时钟频率**

CPU效率与时钟频率、指令条数、CPI有关

#### 注意

​		在描述存储容量时，我们使用的基数为2
​			如：1KB = 2^10 B
​		而在描述速率和频率时，我们使用的基数为10
​			如：1kb/s  = 10^3 b/s

### IPS

指每秒执行的指令条数，计算：主频/CPI ，（解释：单位时间内CPU执行的时钟周期数/每条指令的平均周期数）

#### MIPS

每秒执行多少百万条指令

##### 计算：

=指令条数/(执行时间 x 10^6) = 主频/ (CPI x 10^6)

#### MFLOPS

每秒执行多少百万条浮点数计算

##### 计算：

浮点数操作数 / (执行时间 x 10^6)

#### GFLOPS

浮点数操作数 / (执行时间 x 10^9)

#### TFLOPS

浮点数操作数 / (执行时间 x 10^12)

#### PFLOPS

浮点数操作数 / (执行时间 x 10^15)

#### EFLOPS

浮点数操作数 / (执行时间 x 10^18)

#### ZFLOPS

浮点数操作数 / (执行时间 x 10^21)
浮点数计算性能更多的用于评价科学计算的计算机

### CPU性能各指标理解

主频是指单位时间内产生的脉冲信号数量 

时钟周期是指一个脉冲执行的时间间隔

时钟周期数是指一条指令执行所需的时钟周期个数 

CPI是指每条指令所需要的平均周期数。

CPU执行时间是指一个程序执行所需要的时间，

CPU执行时间=总周期数/主频=(指令数xCPI)/时钟频率=指令数xCPIx时钟周期 



# 数据的表示形式和运算

## 数制和编码

需要复习《深入理解计算机系统》——信息的表示和处理章节

### 进制数基本概念：

#### 数码

指的是一种数字字符，通常用来表示数字的一个符号。比如，十进制中的数码包括 0、1、2、3、4、5、6、7、8、9。

#### 基数

指数码位所用到的数字个数。比如：十进制的基数为10。

#### 位权

指的是一个数字在一个数中所处的位置对其数值的影响。在一个基数为 b 的进制中，每个位置上的数字的位权是 b 的幂，其指数是该数字所在的位置数减去 1。

比如：在十进制中，10\^0=1,10\^1=10。

### 进制转换

#### 常见的二进制与八进制和十六进制转换



#### 十进制转其他进制

整数部分，除基取余，结果倒写；小数部分，乘基取整，结果整写。最后两者拼接即可。

#### 注意

不是所有的十进制小数可以被二进制表示，如：0.3；而任意的二进制小数可以被十进制小数表示。

### *BCD码

即采用4位二进制数表示十进制的0~9的10个数码，按照一定的方法来进行快速转换。

#### 8421码(常用)

即4位二进制分别表示十进制的8421.

#### 余3码

在8421码上加了3=(0011)

#### 2421码

即4位二进制分别表示十进制的2421.

特点：大于或等于5的4位二进制数最高位为1，小于5的最高位为0.

## 定点数

### 定点整数

### 无符号数的减法

是将减号与后一个数看成整体为负数，即将负数转为补码，和前一个数进行求和。

### 原码转补码（快速计算）

![image-20230514152648843](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230514152648843.png)

#### 原理：

负数的原码=它的正数中符号位改为1.

而负数的补码找到右往左的第一个“1”后，除符号位，其余取反，表示为负数的原码。

##### 补码取非：

在位向量上，从右往左，第一个1的权值保留标记位位置k，然后位置k的左边全部取反就是补码的非。

详见《深入理解计算机系统》——小节：补码的非。

### 补码的减法运算

$[A]_补-[B]_补=[A]_补+[-B]_补$

![image-20230514161557324](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230514161557324.png)

该图第一个指：19转-19，求-19的补码；-19转19，求19的补码。

负数的补码相当于它的相反数。

快速计算：从右往左找到第一个1，左边全取反，并在末尾加1.

同一套电路即可处理有符号数和无符号数的加减运算。

### 移码

补码符号数取反就为移码。

移码只能表示整数

### *定点整数小结：

定点整数拓展二进制位，由头部拓展。

#### 原码、反码、补码、移码转换

![image-20230514164718469](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230514164718469.png)

#### 原码、反码、补码、移码之间的表示范围：

![image-20230514164922530](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230514164922530.png)



### *定点小数

顶点小数没有移码。定点小数拓展二进制位，在尾部加

#### 定点小数的原码、反码、补码转换：

与定点整数的原码、反码、补码转换相同。

### 定点小数表示范围

![image-20230514172413005](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230514172413005.png)

### 定点整数和定点小数表示

![image-20230514173324379](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230514173324379.png)

## 奇偶校验码

用于传输信息，验证传输的信息是否在中途出错。

奇校验码:整个校验码（有效信息位和校验位）中“1”的个数为奇数。

偶校验码:整个校验码（有效信息位和校验位）中“1”的个数为偶数。

| 奇偶校验位（1位） | 有效信息位（n位） |
| ----------------- | ----------------- |

也就是根据要求的奇偶校验码，其中1的个数应为奇数和偶数个，从而在奇偶校验位补“1”或“0”。

#### 求奇、偶校验位：

对奇、偶校验码的每一位，使用异或运算，如果得到“1”或者“0”，那么校验位应补“1”或者“0”。

#### 进行奇、偶校验

对奇、偶校验码的每一位，使用异或运算，如果得到1，那么就不符合奇偶校验码规则。

## 电路基本原理

与、或、非、与非、或非、异或的逻辑运算意义，以及其数电元件画法。

异或可用于计算二进制中有多少偶数个1还是奇数个，偶数个1其异或结果为0，奇数个1其异或结果为1.



## 加法器设计

### 一位全加器

A、B为输入的当前一位二进制，$S_i$为本位二进制相加和，$c_{i-1}$表示低位进位数，$c_i$表示本位进位数。

![image-20230515012530882](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515012530882.png)

#### 串行全加器

只有一个全加器，数据逐位串行输入到加法器中进行运算。进位触发器保存“进位位”。

如果操作数（输入）长n位，加法要分n次进行，每一次产生一位和，并且串行逐位地送回寄存器。

![image-20230515115918405](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515115918405.png)



#### 并行全加器

把n个全加器串接起来，就可以进行两个n位数的相加。高位进位依赖低位进位结果。

![image-20230515115830378](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515115830378.png)



##### 并行进位加法器的优化

利用逻辑运算，得出每一个高位计算需要低位的$G_i=A_i\and B_i$和$P_i=A_i\oplus B_i$参与，我们直接将低位的这些计算给n-1个高位进行计算，从而加快计算。

![image-20230515115624864](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515115624864.png)

一般由四个全加器和新线路组成四位的并行全加器。

### 补码加减器

其无符号数和符号数，在底层电路逻辑上的计算相同。

<font color=blue>通过多路选择器和sub将减法利用加法进行实现:</font>减数的补码，按位取反(MUX)，末位加1(Cin取1).

$[A]_补-[B]_补=[A]_补+[-B]_补$，将减法变为加法进行计算。

![image-20230515115545507](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515115545507.png)

即通过sub控制信号，来实现补码作减数还是加数。当sub为1,即减法时，MUX为1的线路连通，并且Cin为1。当sub为0，即加法时，MUX为0的线路连通，并且Cin为0。

### **标志位生成

CF的全称是Carry Flag（进位标志），而OF的全称是Overflow Flag（溢出标志）,SF的全称是Sign Flag（符号标志），ZF的全称是Zero Flag（零标志）。

![image-20230515122542264](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515122542264.png)

## 定点数的移位

![image-20230515140601477](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515140601477.png)

### 原码算数移位

原码的算数移位—―符号位保持不变，仅对数值位进行移位。

定点小数同理。

右移:高位补0，低位舍弃。若舍弃的位=0，则相当于÷2;若舍弃的位A，则会丢失精度

左移:低位补0，高位舍弃。若舍弃的位=0，则相当于×2;若舍弃的位=0，则会出现严重误差

### 反码算数移位

不论左移、右移都是补1.

### 补码算数移位

正数的补码与原码相同，所以正数的补码移位与原码移位规则相同。

负数的补码算数移位：负数补码=反码末位+1导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。
规律―一负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码。

负数补码的算数移位规则如下:

右移（同反码):高位补1，低位舍弃。

左移（同原码):低位补o，高位舍弃。

![image-20230515140132415](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515140132415.png)

利用算数移位求乘法。

### 循环移位

不带进位位的循环移位，会把移出的位重新放置需填补的位置

带进位位的循环移位，会把移出的位重新放置到需填补的位置

![image-20230515141227859](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515141227859.png)

箭头表示算数移位，位向量的每一位移动的方向

### 定点数乘法运算

#### 原码乘法运算

![image-20230515154553452](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515154553452.png)

按照十进制乘法运算同理：在《深入理解计算机系统》整数的补码乘法运算那章节，其二进制乘法，相当于对二进制依次作左移不同位数之和。

此处我们使用逻辑右移+|Y|决定是否加|x|，每进行一次都需要逻辑右移。

结合右边的例题：ACC初始为0，MQ保存Y，然后根据MQ的当前计算位（最低位）是否为1，从而决定ACC是否加|x|，并且每次计算后，ACC中的值都需要逻辑右移一次。



#### 补码的乘法运算

符号位处理：乘数和被乘数的符号位进行异或，结果为1就为负数，结果为0就为正数。

![image-20230515160506195](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515160506195.png)

#### 原码与补码的乘法运算

![image-20230515160328926](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515160328926.png)

##  定点数的除法运算

### 原码的除法运算

![image-20230515164117352](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515164117352.png)

#### 恢复余数法

符号位与数值位分开处理。

在第一个计算机自动商1后，余数为负数，则改为商0，且计算的余数需要恢复，加上[除数]补即可。

![image-20230515170956772](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515170956772.png)



![image-20230515165939424](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515165939424.png)



#### 不恢复余数法

<img src="https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515170932049.png" alt="image-20230515170932049" style="zoom:80%;" />

<img src="https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515170208746.png" alt="image-20230515170208746" style="zoom:80%;" />

### 补码的除法运算

符号位参与运算被除数/余数、除数采用双符号位。

首先，被除数和除数同号，则被除数减去除数;否则异号，被除数加上除数。

然后余数和除数同号，商1，余数左移一位减去除数;余数和除数异号，商0，余数左移一位加上除数。

重复n次，最后末位商恒置1.

## C语言强制转换类型

### 有符号转无符号

直接把有符号的二进制看作无符号的二进制，实际是原数+2^w

### 长范围类型变短范围类型

高位直接截断，仅保留低位

### 短范围类型变长范围类型

使用符号位扩展

## 数据的存储方式和排列

### 存储方式*

数据的最高有效字节（MSB）、最低有效字节（LSB）

比如说，数据在机器内部以字节形式存储，最左边为MSB、最右边为LSB。

例如：01234567H，01为数据的高位字节，67为数据的低位字节

#### 大端法

即数据最高有效字节在内存地址低位

#### 小端法

即数据最高有效字节在内存地址高位

![image-20230515190954782](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515190954782.png)

### 排列方式

现代计算机按字节编制，即每个字节对应一个地址，通常也支持按字、按半字、按字节寻址。

#### 边界对齐方式

每次访问一个字/半字都只需一次访存。

![image-20230515191246407](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515191246407.png)

#### 边界不对齐方式

每次访问一个字/半字可能需要两次访存。

![image-20230515191301620](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515191301620.png)

## 浮点数

### 浮点数的表示

#### 阶码

表示浮点数的大小，是定点整数。常用补码和移码表示。

#### 尾数

表示浮点数的精度，是定点小数。常用原码和补码表示。

#### 逻辑形式：

| S符号位（1为负，0为正） | E阶码(指数转换而来) | 尾数M |
| ----------------------- | ------------------- | ----- |

### 规格化

主要是**左规、右规**的方法。

![image-20230515210725877](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230515210725877.png)

负下溢：表示的负数的绝对值，超出了负数所能表示的最大值。

正下溢：表示的正数，比正数表示的最小值还小。

**表示范围结合图示理解。**



# 存储系统

## 基本概念

![image-20230529163838635](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230529163838635.png)

### 多级层次的存储系统

#### Cache-主存层

解决了<u>CPU访问主存速度不匹配问题</u>，**由于该层的数据是由硬件自动完成的**，所以它对所有程序员透明。

#### 主存-辅助层

实现了<u>虚拟存储系统</u>，解决<u>存储系统的容量问题</u>，**由于该层是由操作系统和硬件共同完成的**，所以它对应用程序员透明。

#### 注意*

需要注意的是<font color=red>上一层的内容是下一层内容的副本</font>，比如：Cache（主存）中的内容是主存（辅存）中内容的副本。

#### 存储周期

存储周期=存取时间+恢复时间。

[计算公式](#计算命中率和访问效率等公式**)



## 存储芯片位置

![image-20230529170253969](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230529170253969.png)

在简单存储模型中一个存储字就是一个存储单元，而字的大小就是字长（比如：机器字长）

### 主存的基本组成

![image-20230610000353939](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230610000353939.png)



### 存储器芯片的基本原理

![image-20230610205736014](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230610205736014.png)

#### 注释

##### 控制电路：

1.用于控制MAR和MDR在稳定电压后才允许操作。

2.读\写控制线和片选线进行传输

##### 头部划线

$\overline{CS}芯片选择信号又称\overline{CE}芯片使能信号$。头上带有划线的是信号为低电压有效。



![image-20230610205756201](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230610205756201.png)

#### 注释

##### 片选线

用于找到指令或数据地址指定的所处存储芯片位置

##### 驱动器

用于稳定信号传输。比如放大信号，使其增大传输距离。

##### 存储芯片的金属引脚个数*

内存存储芯片的引脚=地址线数量+数据线+片选线数+读/写控制线数（另外还有供电引脚、接地引脚）。

##### 存储芯片容量表示*

存储单元个数x存储字长，例如：$8K\times8位=8KB$

#### 寻址

##### 按字寻址

其一个字的首地址=其二进制地址算术 左移两位。

![image-20230610211721931](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230610211721931.png)

###### 存储器中的字

此处的字全称叫存储字，"**按字编址**"是指存储器中一个存储单元的大小是一个字（=字长）。

例如上图：一个存储字包含了4个存储单元，一个存储单元包含了一个字节（8个存储元件）。

#### 编址单位

<font color=red>指具有相同地址的一些存储元件构成的一个单位，</font>可以**按字节**编制，也可以**按字**编制(存储字)。

现代计算机通常按字节编址，即一个存储体内有一个字节。

### SRAM和DRAM的区别

#### 栅极电容和双稳态触发器

![image-20230611150022414](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611150022414.png)

##### 双稳态中的读/写操作

###### 读操作

在**字选择线上加入电压**，通过A和B上的电压信号，从而选择对应的高电压数据线输出对应的状态(0/1)。

###### 写操作

在根据A和B在对应电压表示不同的信号状态(表示是1/0，A和B上的电压)的规则，**在其中一个数据线中输入高电压，而另一个数据线输入一个低电压信号。**

#### 总结

![image-20230611143822674](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611143822674.png)

##### 解释

因为触发器一直通电，有电压保持电容内部电荷数量，所以不需要刷新，也不需要读出后重写。

而也由于触发器的原因，其存储元件体积过大，散热量高，在集成电路中能集成的数量较少，从而存储成本过高。

### DRAM刷新

![image-20230611142144146](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611142144146.png)

当题目未给出刷新周期时，我们默认为2ms。

在计组中，我们一般理解周期，就是一个周期（时间）内执行多少次操作。

#### 刷新类型

![image-20230611142339563](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611142339563.png)

#### 刷新方式

![image-20230611142733343](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611142733343.png)

分散刷新：增加了系统的存取周期(所以无死区)，降低了整机的速度。

集中刷新：产生“死区”或“死时间”，在存储器不进行读写操作时。

异步刷新：最大刷新时间间隔t=刷新周期除以行数。有死区。

##### 特点

1. DRAM刷新是存储器自动进行，不依赖外部的访问且对CPU透明。
2. DRAM的**刷新单位是行**，有芯片内部自行生成行地址。
3. 刷新操作类似于读操作，但不完全相同。
4. 刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。

###   DRAM的地址线复用技术

![image-20230611143642258](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611143642258.png)

行、列地址分别两次通过相同的地址引脚输入到行、列地址缓冲器(缓冲器是一个寄存器)。

## 只读存储器

### 类型

![image-20230611155622952](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611155622952.png)

### BIOS芯片：

主板上的BIOS芯片（ROM） ,存储了“自举装入程序”,负责引导装入操作系统（开机)。

**主存逻辑上将RAM+ROM看作的一个部分，并进行统一编址，先编址ROM，在给RAM编址。**

### 解释

闪存的写速度一般比读速度慢，是因为写之前需要擦除。

有些ROM也具有“随机存取”（访问地址的速度不会因为地址而改变而改变）的特性。

## 双端口RAM

![image-20230613012436484](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230613012436484.png)





## 多模块存储器

### 类型

多体并行存储器和单体多字存储器（提高存储带宽 内部）。

![image-20230613014724534](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230613014724534.png)

### 多体并行存储器

#### 高位交叉编址

**存储体号为地址高位(n个存储体=2^m,m为地址占用的高位位数)，而存储体内的存储单元为剩余地址。**

高位交叉编址的多体存储器**顺序编址**，其访问是连续的，即存取方式还是串行。更多的是进行容量扩展。

#### 低位交叉编址                                               

**存储体号为地址低位(n个存储体=2^m,m为地址占用的低位位数)，而存储体内的存储单元为剩余地址。**

其编址是并行的，分别由存储芯片依次编址完毕后，再由第一个存储芯片开始存储编址。

如下图所示：

![image-20230613013133782](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230613013133782.png)

由于实际存取时间为r，在一个存储体存取完毕后，进入下一个阶段时，也启动另一存储体进行存取访问。（如右图的流水线模型所示）。宏观并行，微观串行。 

#### 当存储不同数量时的细节：

![image-20230613014242486](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230613014242486.png)

当给定一个地址x，如何确定它属于第几个存储体？

1. 根据给定的体号确定
2. 将x%m=x属于第n个模块,m为模块数

###   总结

![image-20230613014925533](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230613014925533.png)



## 主存储器与CPU的连接

![image-20230611192048953](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611192048953.png)

### 存储芯片的输入输出信号

![image-20230611181512758](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611181512758.png)



### 增加主存的存储字长位扩展

增加存储字长，增加数据存储能力

![image-20230611181608205](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611181608205.png)

通过对多个存储芯片的数据输出信号依次连接CPU中对应的数据总线。

#### 完整

![image-20230611181654121](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611181654121.png)

8个8kx1位的存储芯片组成1个8kx8位的存储器，容量为8KB。



### 增加主存的存储字数的字扩展

增加存储字数，增加CPU地址寻址能力。

#### 线选法

![image-20230611185109460](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611185109460.png)

将片选线连接剩余的地址总线，缺点：不能选择处00和11地址开头。

#### 译码片选法

![image-20230611185312347](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611185312347.png)

通过译码器将地址总线的剩余的线连接到2^剩余位个数的存储芯片的片选线。

#### 总结

![image-20230611183754135](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611183754135.png)

### 字位同时扩展

即存储芯片的存储字长（地址线）和存储字数（数据线）同时扩展。

![image-20230611184251104](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611184251104.png)

$\overline{CS}$低电平有效，需要在片选线和输出信号连线的两段一个小圆圈连接，如图所示。

一个存储芯片组为2个16K x 4位，其中一个连接数据总线高4位，一个链接数据总线低4位。

地址总线剩余的两条线$A_{14},A_{15}$用2-4译码器与能够表示的4组存储芯片的片选线连接。

### *译码器补充知识

在考纲参考教材《计组》中的主存储器对应章节有更为详细解释。

![image-20230611190810519](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230611190810519.png)

### 解释

$\overline{MREQ}$表示译码器是否生效，低电平的时候表示所对应的译码器有效；而高电平表示无效。

#### 左下角图示和右上图示过程解释：

当CPU传输地址信号后，会等待地址信号稳定，然后再通过$\overline{MREQ}$内存使能，使对应内存的译码器生效，而地址总线的剩余信号通过译码器能找到对应存储芯片的片选线地址，使该存储芯片被选择操作生效。

### CPU与存储器连接的计算题

#### **告知芯片类型，需按照题目已知地址条件，画出CPU与存储器的连接图。**

##### 步骤：

1. 按题目要求，先写出地址线的范围，以及求出地址数。

2. 根据1所写地址范围和题干已给芯片类型，选出正确的芯片类型和芯片容量。

3. 根据1所写地址数，分配地址线

4. 根据剩余的地址线和译码器选择正确的片选信号（及剩余地址线的哪部分为输入信号并对应着译码器的哪部分为输出信号）
5. 补全部分片选线所需的逻辑运算

#### 告知地址总线根数Ad、数据总线根数Dd和存储芯片的规格x k X n位

1. 将存储芯片的地址选通线根数算出$m=log_2x+10$,这个10是将k算到B为单位，因为常见的地址以字节为单位。

2. 将地址总线$Ad-m$得到剩余地址线根数$r$，其作用于译码器的输入信号，$得到对应的片选线根数=2^r$，

3. 根据数据总线根数是否等于存储芯片数据选通线根数n来判断，当相等时，则选用芯片就为$2^r$个；否则还需要将数据总线根数Dd除以存储芯片数据选通线根数n，将存储芯片进行组合将数据总线占满，则选用芯片就$2^r\times (Dd\div n)$个。

.

## 外存储器

### 磁盘存储器

![image-20230615230546233](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230615230546233.png)



#### 磁盘的组成

![image-20230616000009586](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230616000009586.png)

#### 磁盘的性能指标：

##### 磁盘的容量和记录密度

![image-20230615231722453](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230615231722453.png)

每个磁道存储位的数量相同（只不过靠外的磁道其位密度比内圈小）

##### *平均存取时间

![image-20230615231914096](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230615231914096.png)

**有的题目还要求加上磁盘控制器延迟的时间。**寻道时间和旋转延迟时间通常取平均值。

<font color=red>题目不会直接告诉寻道、旋转延迟和数据传输所花的时间，需要通过自己读题构造式子得出。</font>

一般通过转速的倒数得到磁盘转动一圈的时间，而它除以2得到的是旋转延迟的时间。

若已告诉一条磁道有多少扇区时，将旋转一圈的时间除以扇区数得到读取一个扇区的时间。

##### 数据传输率

磁盘存储器在单位时间内向主机传送数据的字节数。

磁盘转速：r(转/秒)，每条磁道容量为N个字节，则数据传输率为$D_r=rN$

#### 磁盘地址

如下图：且包含例题1：

![image-20230615232532310](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230615232532310.png)

#### 硬盘的工作过程

硬盘的主要操作是寻址、读盘、写盘。

每个操作对应唯一的一个控制字，比如：硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作时串行的，不可能在同一时间进行读写操作，也不可能在同一时间进行读或者写多组数据。

因为计算机是并行传输数据，所以需要并行转串行变换的电路。

#### 磁盘阵列

RAID是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、安全性和可靠性。

RAID0：无冗余和无校验的磁盘阵列。没有容错能力。

RAID1：镜像磁盘阵列。

RAID2~5：通过数据校验提高容错能力。

### 固态磁盘

#### 总概

![image-20230616001835768](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230616001835768.png)

#### 组成

![image-20230616000554207](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230616000554207.png)

固态硬盘的一个页对应磁盘的一个块/扇区，SSD的一个块对应HDD的一个磁道。

## Cache高速缓存器

用于Cache-主存层级。

### 程序访问的局部性原理

#### 空间局部性

未来要使用的指令与现在使用的指令其位置是邻近的。

#### 时间局部性

未来要使用的指令很大可能是现在正在使用的指令。

### Cache-主存系统的效率

访问cache的同时也在访问主存。

#### Cache命中率

![image-20230617093708000](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617093708000.png)

$命中率h=\frac{Cache的存取次数[主存的存取次数]}{Cache和主存存取次数之和}$

#### 计算命中率和访问效率等公式**

$主存访问时间与Cache访问时间的倍率r=两者存储周期之比=\frac{T_m}{T_c}]$

$访问Cache的平均时间=t_C$

$访问主存的平均时间=t_m$

##### Cache-主存系统的平均访问时间:

$Cache和主存同时访问:t_a=ht_c+(1-h)t_m$

$Cache和主存不同时访问:t_a=ht_c+(1-h)(t_c+t_m)$

$[如果t_c和t_m成r倍，则也=ht_c+(1-h)rt_c)]$

##### Cache主存系统的效率e:

$访问效率e=\frac{访问Cache的时间}{平均访存时间}=\frac{t_c}{ht_c+(1-h)t_m}=\frac{1}{[h+(1-h)r]}$

$平均访问时间T_a=\frac{T_e}{e}$

提高效率:$\frac{原主存访问时间}{现平均访问时间}$

### 组成

将主存的存储空间“分块”，如:每1KB为一块。

<font color=blue>利用程序局部性原理，将主存某地址的邻近范围的地址组成统一个Cache行。</font>它们之间通过块内地址区分。

<font color=red>CPU与Cache之间的数据交换以字为单位（数据总线）。主存与cache之间以“块”为单位（块大小相等）进行数据交换 。</font>主存中只有数据块（数据块用于保存数据）。

![image-20230617095448643](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617095448643.png)

<font color=red>每次访问都是访问的一个存储块，而每次访问到主存块时，都会将该主存块调入Cache中。</font>

### Cache基本原理

![image-20230616183208159](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230616183208159.png)

1. CPU发起访问主存某存储块请求
2. Cache获取CPU访问地址信息，根据与Cache的标记号进行比较，确认Cache是否命中。
3. 若命中，则将Cache存储块内容传输到数据总线传输给CPU；若未命中，则查询是否可将新主存的存储块传入Cache中。
4. 若可以，则装入Cache，若不可以，则通过Cache的替换算法将该主存的存储块替换掉Cache中的某个存储块。而Cache的旧存储块要么写回要么擦除。

#### 重要部件 

#### Cache地址映射 

主存的块可以放在Cache的哪个块当中，得到的地址。

#### Cache变换机构

将主存的块号转变成Cache的块号，或者将主存的地址转变为Cache的地址。完成是的查找操作。

地址映射变换机构是将CPU送来的主存地址变换为Cache的地址。由于主存和Cache的块大小相同。所以块内地址是从块的起始地址进行偏移得到。因此地址变换主要是主存的块号与Cache块号的转换。

#### Cache存储体

以块为单位与主存交换信息。

#### Cache替换机构

当储存块无法被填入Cache块中，则启动Cache替换机构，根据[替换算法](#替换策略)，将Cache中某块内容写回到主存或者作废，将新需要用的存储块写入当中。

### Cache的读写操作

#### 读



#### 写

解决Cache与主存数据一致性问题。

##### 写命中

###### 写回法

利用脏位，表示其Cache的内容是否被修改。在Cache的块被退回时，才把该内容在主存的对应数据块中重写。

![image-20230617154857685](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617154857685.png)



###### 全写法(直写法)

CPU同时对Cache和**利用写缓冲**对主存进行写操作。

![image-20230617154742479](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617154742479.png)

##### 写不命中

###### 写分配法

写分配法(write-allocate)——当CPU对Cache写不命中时，**把主存中的块调入Cache，在Cache中修改**。通常搭配写回法使用。

![image-20230617155243807](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617155243807.png)

###### 非写分配法

而当CPU对Cache写不命中时，**只会写入主存而不调入Cache**。

<font color=red>注意：非写分配法只有在CPU进行读未命中时，才会将主存块调入到Cache中。</font>

![image-20230617155437304](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617155437304.png)

 



### Cache的改进

增加Cache的级数：片载（片内）Cache数；片外Cache数

统一缓存和分立缓存，即指令Cache和数据Cache位数相同。

### *Cache-主存的地址映射

解决了Cache和数据块的对应关系。

![image-20230617114622070](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617114622070.png)

在Cache的块需要有一个标记，其存储的是主存块的块号，并且仍需要有一个有效位(0或1)，表示其Cache块的信息是否有有效。

#### 直接映射

##### 过程

使用块号%Cache块总数，得到在Cache中的行数。

但这样的映射关系，其空间利用率不高，因为每个行号的块内容被固定于对应主存块号范围的内容（即Cache0行只能保存主存块号第0个或者第2^n个）。

##### 优化标记

通过下图所示，我们可知当Cache总块数为8，而知道Cache的行数的二进制数对应着主存块的块号二进制里的最后三位，如此，我们就可将原标记为22位分为19位，另三位表示为Cache的行号。

在进行访存时，就先查询行号，然后才匹配标记，以及有效位是否为1.

![image-20230617120216636](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617120216636.png)

有多少块就有多少行，$2^n$行，n为行号的在主存块号末位所占位数。

#### 全相联映射

##### 过程：

当CPU访存时，会将主存块号与Cache的所有标记进行匹配，当查找到时，还会查询有效位是否为1。否则，需要访问主存块，并将该块根据替换策略填入Cache的某个块中。

![image-20230617115827702](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617115827702.png)

#### 组相联映射



![image-20230617121158127](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617121158127.png)

将Cache分为n个组，n为组号的在主存块号末位所占位数。

#### 总结

![image-20230617121322321](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617121322321.png)

### *Cache理解需要注意点

<font color=red>Cache的高速缓存块用于保存主存的数据块。</font>**所以Cache中每个数据块对应着主存的一个数据块。**

#### 什么是数据块？

**物理上主存中实际只有数据块，且数据块只存储的数据。**

通过标记和索引号确定唯一的数据块的所处位置。

#### 什么是数据字或数据字节？

<font  color=red>**一个数据块中有多个数据字(节)**，而数据字(字节)用块内地址或块偏移来确定在所在数据块中的位置</font>。

通过标志位、索引号和块内地址可以确定数据块中某个数据字节的位置。

<font color=red>当系统按字或字节编制时，则相应的数据字或数据字节是数据块的最小可寻址存储单位。</font>

主存并不保存地址！地址只是用于访问数据块的位置！

#### 什么是块偏移(块内地址)

用于确定数据块中的某个数据最小可寻址单位(字或字节)。

#### 例:一个高速缓存行

在Cache中，每一个Cache缓存行，具有有效位，标记位，以及一个或多个数据块。

缓存字节=数据字节。

| 有效位 | 标志位t  | 数据块0               | 数据块...             | 数据块n               |
| ------ | -------- | --------------------- | --------------------- | --------------------- |
| 0或1   | 同标志位 | 缓存字节1...缓存字节b | 缓存字节1...缓存字节b | 缓存字节1...缓存字节b |

#### *解读映射规则

我们需要知道的是，<font color=blue>**主存的一个数据块其实只缓存在Cache的一个缓存行中**</font>，只不过因为不同的映射规则，具有不同的索引方式，而查找的方式不同罢了。例如：

直接相联映射方式：Cache的一个缓存行对应一个主存的数据块(通过行数对主存块号求余得到所在缓存行号)。

组相联映射方式：Cache的一个缓存行也只对应一个主存的数据块，只不过通过组号对主存块号求余所得的组号，将一部分数据块设定索引号为同一个而已。

<font color=brown>标记位是用于在Cache缓存行中是否命中的判断，它和组号/行号能够将该数据块定位到主存中位置(为主存块的位置)，再加上偏移位，能够精准定位在主存块中的所处位置(为数据字(或数据字长)的位置)。</font>

### 结合地址映射，本节题目中需要注意的参数

注意区分Cache地址参数和主存访问地址参数。

前三个参数属于Cache的地址参数。

| 参数         | 位数                                            |
| ------------ | ----------------------------------------------- |
| 有效位       | 1(值:1或0)                                      |
| 修改位(脏位) | 回写法中用于标记是否回写的1位(0或1)             |
| 引用位       | LRU或FIFO替换算法使用位(0或1)                   |
| 标记位       | t(常于主存地址高位)                             |
| 缓存地址     | D(常于主存低位)                                 |
| 索引位       | s(常于主存中间位，组相连:组号s；直接映射:行号e) |
| 偏移量位数   | b(表示数据块的大小B=2^b 默认单位为字节)         |

主存地址由标记+索引号+块内地址组成。

通常主存地址位数$m=标记的位数t+索引号的位数s+偏移量的位数b$。

通过利用块的大小B计算Cache缓存块的个数,然后根据一行多少块或分组，求行号s或组号e。

而数据块的大小B默认单位为字节，其$B=2^b$的b表示了偏移量位数。

不包括像有效位和标记位这样开销的高速缓存大小（字节)，C=BXEXS 

### 替换策略

解决Cache容量比主存小的问题。

在全相联映射中，全局都可替换；在直接映射中，直接替换对应块的内容；在组相联映射中，需要在分组内选择替换哪一块。

#### 先进先出FIFO算法

选择最早调入的字块进行替换，不记录各字块的使用情况。容易实现，开销小，但没有根据访存的局部性原理。

![image-20230617143008799](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617143008799.png)

##### 抖动现象

Cache反复地加载和替换相同的高速缓存块的组。

#### *近期最少使用算法LRU

有较好的利用访存局部性，利用各个字块拥有对应的计数器，计数器根据规则进行对每一次的访存操作进行计数，将访问次数最少的块进行替换。**即计数器值越大越表示最近没有被访问过。**

![image-20230617144007087](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617144007087.png)

##### 做题时

手算方法为，当前访问主存块未命中且无空闲行时，将从左侧找到与之最近访问时间最久的那个块。

如上图：当访问5主存块时，从左边找到，3所在的主存块是最久没被访问到的存储块。我们就讲5放入其中进行内容替换。

<font color=red>当被频繁访问的主存块数量>Cache行的数量时，也有可能发生抖动：</font>

如：{1,2,3,4,5,1,2,3,4,5,1,2....},这样的访问除了刚开始填补完所有Cache块的刚开始情况{1,2,3,4}，后续访问会使每个Cache块的内容发生变动。

#### 最不经常使用算法LFU

最不经常使用算法(LFU, Least Frequently Used )——为每一个Cache块设置一个“计数器”，用于记录每个cache块被访问过几次。当Cache满后替换“计数器”最小的那个块。**即计数器越大则越表示该块近期被访问。**

![image-20230617145518694](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617145518694.png)

**规则：当进行访问后，对其相应的计数器加1。当Cache满后替换“计数器”值最小的块，若有多个块计数器值最小，则根据FIFO算法或者将行号最小的替换。**

LFU算法——曾经被经常访问的主存块在未来不一定会用到(如:微信视频聊天相关的块）,从而导致缓存空间的浪费，所以并没有很好地遵循局部性原理（该算法实际存储了全局的变化性），因此实际运行效果不如LRU。

#### 随机法RAND 

利用随机数产生器产生的随机数去选择替换的块。

### 多级Cache

现代计算机常采用多级Cache，离CPU越近的速度越快，容量越小离CPU越远的速度越慢，容量越大。

![image-20230617164320748](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230617164320748.png)

### Cache行的大小与命中率的关系

适度长度的Cache行，有益于体现出程序访问的空间局部性，将邻近空间存放在一起，增加命中率。

但当Cache行过大时，使失效损失变大，重新缓存数据块的时间过长；Cache项数变少，命中率降低。

### 取指令在Cache中产生缺失异常时

1. 程序计数器恢复当前指令的值
2. 对主存进行读操作(准备将需要的数据块进行传输在数据总线中)
3. 将读入的指令写入Cache中，并更改标志位和有效位
4. 重新执行当前指令(在程序计数器当前的指令)

## 选择题总结

1. 某计算机的cache共有16块，采用二路组相联映射方式（即每组两块），每个主存块大小为32B，按字节编址，主存129单元所在主存块应装入的cache组号是？

- 答： 这里的主存129单元并不是说第129主存块，而是说第129主存单元(存储单元：保存一串二进制位，一个二进制位叫存储元件)，此处按字节编制，也就是说主存129单元=128B=也就是地址为129，然后主存块大小为32B，129/主存块大小=块号，块号%组数=组号。

2. 

## 虚拟存储器

个人理解：虚拟内存用于主存和辅存层级。

### 使用虚拟内存的三个原因：

1. 虚拟内存使用DRAM作为存储在磁盘上的实际数据的缓存器。
2. 简化了内存的管理，从逻辑上而言 每个程序的虚拟内存都是同样的格式，但实际它们对应的物理上存储是离散分布的。
3. 虚拟内存支持创建受保护的私有地址空间。

### 什么是虚拟内存

**<font color=red>一句话：虚拟内存是利用辅存空间去扩展内存空间</font>**。

在虚拟内存系统中，虚拟内存被划分为固定大小的页面（通常是4KB）。

在主存的MMU(内存管理单元)进行虚拟地址转换为物理地址。主存和辅存的地址空间统一编址。

**<font color=red>虚拟内存采用全相联映射地址方式，写策略采用回写法。</font>**

#### 页面

**虚拟内存中的页面(虚拟页:VP)保存的是实际的物理内容，而不是虚拟地址本身。**详细点来说，页面对应着实际的物理内存或磁盘上的交换空间。而虚拟内存就是一系列页面的集合。

在虚拟内存管理中，将虚拟内存空间按照固定大小划分成多个连续的区域，每个区域就被称为一个"页面"（Virtual Page）。而主存（RAM）也会按照相同的大小划分成多个连续的区域，每个区域被称为一个"页框"（Page Frame）。

虚拟内存的页面和主存的页框之间通过页表来建立映射关系。操作系统根据页表将虚拟地址转换为对应的物理地址，从而将虚拟内存中的页面映射到主存中的页框，实现了虚拟内存的管理和数据的访问。这种页面到页框的映射机制允许多个进程共享主存，并提供了更大的虚拟地址空间，以及更高的内存隔离性。

##### 页面大小问题

当页面过小时，虚拟存储器中的页面数变多，当虚拟内存的页面数容量大于主存容量时，此时的操作速度会变慢。

当页面过大时，虚拟存储器中的页面数变少，但因为虚拟存储容量大于主存容量，主存可存放的页面数变少，而当需要新调入页面时，操作速度会变慢。



### 虚拟内存的页面的三种状态：

1. 未分配的

即在虚拟内存中还未分配(或未创建)的页，说明它不占用任何磁盘空间。

2. 已缓存的

即在虚拟内存已分配且已经将内容缓存到主存中。

3. 未缓存的

即虚拟内存已分配（已占用磁盘空间），但并未缓存到主存中。

### 页式虚拟存储器

#### 结构

页式虚拟存储器是以页为基本存储单位。<font color=blue>虚拟空间与主存空间都被划分为同样大小的页</font>。主存的页被称为实页或页框，而虚拟内存的页被称为虚页。

而多个虚拟页面可以映射到同一个共享的物理页面上。

#### 页表

页表是存放在物理内存之中的数据结构。**页表用于将虚拟地址映射到物理地址**。**页表的基本单位是页表条目(或者页表项)PTE,一般由一位有效位和一个n位地址字段组成的。**<u>地址字段表示DRAM相应的物理页号。</u>

##### 有效位

###### 为1时 

此时表示已缓存。

###### 为0和地址字段不为空时

此时表示未缓存。

为0和地址字段为空时

此时表示未分配。

当然除了有效位以外，**有时候还应具有脏位(用于回写)和引用位(用于替换策略:FIFO，LRU)**。

#### 页命中

当地址翻译硬件接受到CPU发送的虚拟地址后，在页表中找到对应的PTE，而在PTE中因为设置了有效位，所以通过有效位可知虚拟内存的对应虚拟页是否缓存到主存中。

当访问的虚拟地址在页表中的PTE的有效位为1时，则CPU将访问PTE的数据字段保存的主存地址，从而表示命中。

#### 缺页

也就是当有效位为0时，我们需要从虚拟内存中把所需的虚拟页缓存到主存中，并在页表的PTE中设置有效位为1，地址字段为主存地址。

流程：1.指令触发缺页异常；2.选择牺牲页进行内容替换；3.缓存完毕后，重新启动触发缺页异常的指令。

**缺页由操作系统提供的缺页处理程序完成。**

#### 页面换入或页面调度

在磁盘和内存之间传送页的行为叫交换。

##### 按需页面调度

当有不命中发生时，才换入页面的策略。

#### 局部性

虚拟内存通常使用时间局部性缓存数据到主存之中。虚拟内存的局部性原理含义是指：程序的执行过程中，对主存的访问是不均匀的。

###### 工作集

程序趋于一个较小的活动页面集合上工作

###### 抖动

当工作集大小大于物理内存的大小，会出现频繁的数据交换，这种情况就成为抖动。



### 虚拟内存作为内存管理的工具

VM简化了链接和加载、共享、内存分配。

即每个进程的内存映像使用了相同的基本格式，即相同的VM格式，对于特定部分，是从相同的虚拟地址开始，例如：代码段和用户栈的位置，以及用户栈的扩展方式。

简化加载：是因为加载器是在CPU取指令是引用页，或者某条指令正在引用一个内存中的页时引用。

将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为**内存映射**。

简化共享：独立地址空间为操作系统提供了一个管理用户进程和系统自身之间共享的一致机制。

简化内存分配：虚拟内存为向用户进程提供一个简单的分配额外内存的机制。即在虚拟内存上分配了连续的虚拟页，而在物理内存上不一定连续。

### 虚拟内存作为内存保护的工具

通过对PTE上添加一些额外的许可位(用于反映是否可执行某些操作)来控制对一个虚拟页面内容的访问。

比如：在PTE中添加SUP、READ、WRITE许可位，来控制该虚拟页在进程处于什么运行模式下才可访问，以及访问时可拥有的读写权限。SUP为1时，表示该进程只有在内核模式下才能访问该页。

当指令违反了许可条件，CPU将处罚一个一般保护故障，将控制传递个一个内核中的异常处理程序。在Linux shell中这种异常报告称之为“段错误”。

### 地址翻译

#### 地址翻译符号表：

![image-20230623143914533](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230623143914533.png)

#### 页表的地址翻译结构：

在CPU中的一个控制寄存器，**页表基址寄存器(PTBR)用于指向当前页表起始地址**。

下图中的虚拟地址为n位，物理地址为m位，其中虚拟页偏移量和物理页偏移量存储同一个数据信息——为页内地址(因为其PTE的页面存储着物理页号，需要偏移量来确定需要的数据字节在某个数据页的所处位置)。<font color=blue>此时说是页内地址，是因为虚拟内存和主存都进行同大小的分页。</font>

即逻辑地址转换为物理地址，通过虚拟地址的虚拟页号找到虚拟页条目，然后获取物理页号，物理地址由物理页号+虚拟页偏移量。

![image-20230623145025150](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230623145025150.png)

#### 页面命中图示

![image-20230623145518311](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230623145518311.png)

#### 页面不命中图示

![image-20230623145529976](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230623145529976.png)



### 快表(仍是页式虚拟存储器)

在考纲书中，快表(TLB)是指页表的部分页表项(页表条目)被缓存到Cache中，以及缓存到内存就是慢表。而在《深入理解计算机系统》一书中指出TLB是处于MMU中的一个小缓存，名称叫翻译后备缓冲器。<font color=red>**翻译后备缓冲器就是快表**</font>。需要注意的是：Cache和MMU都是处于CPU的寄存器。

TLB中每一行都保存着一个PTE组成的块（在CSAPP一书中结构为:TLB标记，TLB索引，VPO虚拟页偏移[块内地址]）。

#### 物理结构

**Cache常使用SRAM，而TLB使用相联存储器或者SRAM**



### 具有TLB和Cache的多级存储系统

#### 下图为CPU使用虚拟地址的过程图

##### 访问过程

下图是一个具有TLB和Cache的多级存储系统，其中Cache采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换；若未命中，则TLB缺失，需要访问主存去查页表。图中所示的是两级页表方式，虚页号被分成<u>页目录索引</u>和<u>页表索引</u>（作为对应页目录索引的页表基址的偏移量）两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。

![Screenshot_20230623_163156](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/Screenshot_20230623_163156.jpg)

**上图中的页表使用了二级页表，虚拟页号被拆分成目录索引(一级页号)和页表索引(二级页号)。**

**其中一级页表的页表项指向的二级页表的基地址，从而建立的索引。**

通过页表项存储的物理页号|虚拟地址中的页内地址。

以及TLB的页表项中的虚页号由TLB标记和TLB索引组成。



#### CPU访存过程和缺少情况：

当发生缺页时，有缺页处理程序进行处理。

![image-20230623161159599](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230623161159599.png)



### 例：一个Linux进程的虚拟内存

![image-20230623153008819](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230623153008819.png)

### 段式虚拟存储器

按程序的逻辑结构划分段。虚拟地址:段号和段内地址。因为段的长度不一，所以段表的每一行都需要给出段首地址和段长度，以及判断是否缓存主存的装入位。



### 段页式虚拟存储器

把程序按逻辑结构分段。每段再划分固定大小的页，主存空间也划分为大小项的的页。程序对主存的调入和调出仍以页为传输的基本单位。每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍。段的起点必须是某一页的起点。

虚拟地址分为：段号，段内页号和段内地址。

CPU根据虚拟地址访存时：

1. 首先根据段号得到<u>段表</u>地址，再从段表中得到页表的起始地址。

2. 然后与虚拟段内页号合成，得到<u>页表</u>地址。

3. 根据页表地址从也表中取出物理页号，然后与页内地址(段内地址)合成物理地址。

### 总结：

1. 一个程序的实例是进程，**每个进程拥有一个页表**，而页表存储在主存之中(页表是一种数据结构)。

2. 进程的虚拟内存空间大小由操作系统的地址空间大小决定(也就是程序计数器位数=MAR位数)。
3. 虚拟内存的页(页面)对应物理内存的页框。
4. 虚拟内存的页面是指进程在辅存中的数据，而当主存需要时会进行页面调度将某进程的某个/某些页面加载到主存之中。
5. 操作系统执行程序需要经历过两次地址的映射：虚拟地址映射和物理地址映射。
6. 操作系统任意时刻只能访问一个进程的页表。
7. 页表中的页表项包含有效位和物理页号，以及隐含页表号。
8. 快表是用于保存最近访问的页表项的高速缓存器。
9. 



### 虚拟存储器和Cache的比较

#### 相同点

1. 都是为了提高性能。

2. 将数据重新划分（Cache划分为块，虚拟存储器为页）
3. 有地址映射、替换算法和更新策略(如：写策略)
4. 都是依据局部性原理，将工作集缓存在传输速度相对块的部件中

#### 不同点

1. Cache用于解决主存与CPU之间的速度，而虚拟存储器用于扩展主存容量不足的情况。
2. Cache的所有操作是自动完成，属于硬件存储器，对所有程序员透明；而虚拟存储器是由操作系统和硬件共同完成，属于逻辑上的存储器，只对应用程序员透明。
3. 对于不命中的影响：Cache要低于虚拟存储器在这种情况下对系统的影响。
4. CPU与Cache和主存建立了DMA通路。而辅存只能先调入主存，才能被CPU访问。



# 总线

## 基本概念

### 总线的定义

是一组能为多个部件`分时`和`共享`的信息传输线路。

`分时`是指同一时刻只允许一个部件向总线发送信息。若系统中有多个部件，则它们只能分时地向总线发送信息。

`共享`是指总线上可以连接多个部件，各个部件之间互相交换信息可以通过总线分时共享，多个部件同时从总线上接受信息。

<u>总线结构便于增减外设，也减少信息传输线的条数。</u>

#### 主设备

获得总线控制权的设备。

#### 从设备

被主设备访问的设备，只能响应从主设备发来的各种总线命令。

## 总线分类

### 按数据传输方式

#### 串行总线

每次只能传输一位数据。例：USB

#### 并行总线

每次可以传输多位数据。

![image-20230624230748773](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230624230748773.png)

#### 为什么并行不一定有串行总线快？

结合后面的总线带宽计算可得出，需要根据`总线工作频率和总线位宽`来看。

虽然并行的总线位宽要比串行大，但是总线工作频率不一定比串行快。

当串并行的工作频率相同时，串行总线传输速度要比并行慢。

并行总线的工作频率无法持续提高（因为信号线数量越多会互相产生干扰

### 按总线连接的功能部件

#### 片内总线

片内总线是**芯片内部的总线**。
它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。

#### 系统总线

系统总线是计算机系统内**各功能部件**(CPU、主存、I/O接口)**之间相互连接的总线**。按系统总线传输信息内容的不同，又可分为3类:数据总线、地址总线和控制总线。

##### 数据总线

数据总线用来传输各功能部件之间的数据信息，它是**双向传输**总线，**其位数与机器字长、存储字长有关。**

`数据通路：表示数据流经的路径（逻辑上的）。`

`而数据总线是承载数据的媒介（物理上的）`

##### 地址总线

地址总线用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址,它是**单向传输**总线，**地址总线的位数与主存地址空间的大小有关**。

##### 控制总线

控制总线传输的是控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号。

#### 系统总线的结构

##### 单总线结构

![image-20230624232843329](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230624232843329.png)

##### 双总线结构

![image-20230624233225749](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230624233225749.png)

###### 通道

具有特殊功能的处理器，能对I/O设备进行统一管理。通道程序放在主存中。

###### 支持突发(猝发)传送:

送出一个地址，收到多个地址连续的数据。例如：指令序列。

##### 三总线结构

![image-20230624233806856](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230624233806856.png)

三总线同一时间只有一条总线在工作。

##### 扩展：四总线结构

 ![image-20230624234107478](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230624234107478.png)

北桥chip用于与CPU的联系并控制内存(还有显卡等高速设备)

南桥Chip用于集成更多功能：负责I/O总线之间的通信。

#### 通信总线

通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备)之间信息传送的总线,通信总线也称为外部总线。例：网线。 

#### 总结

![image-20230624234304937](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230624234304937.png)

## 总线性能

###  总线周期

通常把CPU通过总线对微处理器外部(存储器或I/O端口)进行一次访问所需要的时间称为一个总线周期。

简言之一次总线操作所需的时间。

### 总线时钟周期

就是存储器的时钟周期。一个操作所需时间。

### 总线工作频率

总线周期的倒数，一秒内传送几次数据（一秒内进行几次总线操作）。

###  总线时钟频率

时钟周期的倒数，即一秒内有多少个时钟周期。

![image-20230625002143317](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625002143317.png)

### 总线宽度

又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位（bit）总线。

### 总线带宽

可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。

![image-20230625004851324](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625004851324.png)

#### 例题：

![image-20230625003200947](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625003200947.png)

### 总线复用

总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。

### 信号线数

地址总线、数据总线和控制总线3种总线数的总和称为信号线数。

### 了解知识点

#### 总线总裁

多个主设备同时竞争主线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。按照总线仲裁电路的位置不同，仲裁方式分为;

##### 集中式仲裁

链式查询方式、计数器定时查询方式、独立请求方式。

##### 分布式仲裁：

分布式仲裁不需要中央仲裁器，每个潜在的主方功能模块都有自己的仲裁号和仲裁器。当它们有总线请求时，把它们唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号大，则它的总线请求不予响应，并撤消它的仲裁号。

#### 总线标准

目前，典型的总线标准有ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB等。

这些总线标准的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等，相信大家对其中的一些标准并不陌生，我们依次来介绍。

1）ISA：ISA（Industry Standard Architecture，工业标准体系结构）总线是最早出现的微型计算机的系统总线，应用在IBM 的AT机上。

2）EISA：EISA（Extended Industry Standard Architecture，扩展的ISA）总线是为配合32位CPU而设计的**扩展总线**，EISA对ISA完全兼容。

3）VESA：VESA（Video Electronics Standards Association，视频电子标准协会）总线是一个32位标准的**计算机局部总线**，是针对多媒体PC 要求高速传送活动图像的大量数据应运而生的。

4）PCI：PCI（Peripheral Component Interconnect，外部设备互连）总线是高性能的32位或64位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统设计的互连机制。目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线支持即插即用。PCI总线是一个与处理器时钟频率无关的高速外围总线，**属于局部总线**。PCI总线可通过桥连接实现多层PCI总线。

5）PCI-Express（PCI-E）：PCI-Express是**最新的总线和接口标准**，它将全面取代现行的PC和AGP，最终统一总线标准。**通过串行数据包传输数据。**

6）AGP：AGP（Accelerated Graphics Port，加速图形接口）是一种**视频接口标准**，专用于连接主存和图形存储器，**属于局部总线**。AGP技术为传输视频和三维图形数据提供了切实可行的解决方案。

7）RS-232C：是RS-232C（Recommended Standard，RS）是由美国电子工业协会（EIA）推荐的一种**串行通信总线**，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口。

8）USB：USB（Universal Serial Bus，**通用串行总线**）是一种连接外部设备的I/O总线，属于设备总线。具有即插即用、热插拔等优点，有很强的连接能力。



## 总线事务和定时

### 总线周期的四个阶段

##### 申请分配阶段：

设备提出总线使用请求，经过总线仲裁机构决定将下一传输周期的总线使用权授予某一个申请者。

此阶段也可分为`传输请求`和`总线仲裁`两个阶段。

##### 寻址阶段：

获得使用权的主设备通过总线发出本次要访问的从模块的地址及有关命令，启动本次参与的从模块；

##### 传输阶段：

主模块和从模块进行数据交换，可单向或双向进行数据传送；

##### 结束阶段：

主模块的有关信息均从系统总线上撤除，让出总线使用权。

### 总线定时

是指总线在双方交换数据的过程中需要在时间上对配合关系进行控制，其实质是一种协议或规则。

#### 同步定时方式

同步定时方式是指**系统采用一个统一的时钟信号来协调(或者统一的时序控制)**发送和接收双方的传送定时关系。

若干个时钟产生相等的时间间隔，每个间隔构成一个总线周期。

在一个总线周期中，发送方和接收方可进行一次数据传送。

因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。

##### 优点:

传送速度快，具有较高的传输速率;

总线控制逻辑简单。

##### 缺点:

主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差。

**同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统**。

![image-20230625134921212](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625134921212.png)

#### 异步定时方式

在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，**完全依靠传送双方相互制约的“握手”信号来实现定时控制。**

主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。

##### 优点:

总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。

##### 缺点:

比同步控制方式稍复杂一些，速度比同步定时方式慢。

根据请求和回答信号的撤销是否互锁，可分以下三种类型：

![image-20230625135737495](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625135737495.png)

#### 半同步通信

利用"等待"响应信号，将其余设备进行等待，直到较慢设备准备完成后，继续进行。但是总线传输周期中划分了是等时间周期。

![image-20230625141007665](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625141007665.png)

#### 分离式通信

![image-20230625140927419](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230625140927419.png)



# I/O设备



# 中央处理器

## CPU的功能

### 指令控制

完成取指令、分析指令和执行指令的操作，即程序的顺序控制。

### 操作控制

一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。

### 时间控制

对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。

### 数据加工

对数据进行算术和逻辑运算。

### 中断处理

对计算机运行过程中出现的异常情况和特殊请求进行处理。

### 运算器的功能

对数据进行加工

### 控制器的功能

协调并控制计算机对各部件执行程序的指令序列。取指令，分析指令，执行指令。

#### 取指令:

自动形成指令地址;自动发出取指令的命令。

#### 分析指令:

操作码译码(分析本条指令要完成什么操作)，形成操作数的有效地址。

#### 执行指令:

根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作。

执行指令的主要目的是：通过微操作信号发生器，来生成控制信号序列，来控制计算机各个部件。

#### 中断处理:

管理总线及输入输出，处理异常情况(如掉电)和特殊请求(如打印机请求打印一行字符)。

## CPU的基本结构

### 运算器的基本结构

#### 算术逻辑单元ALU

进行算术/逻辑运算

#### 暂存寄存器

通过暂存从主存读取的数据或者稳定输出 信号，来解决同时在数据通路同时传输数据的冲突。这个数据不能存放在通用寄存器中，否则会破坏其原有内容。如:两个操作数分别来自主存和寄存器R0，最后结果存回R0，那么从主存中取来的操作数直接放入暂存器，就不会破坏运算前R0的内容。

#### 通用寄存器组

在x86架构中，常见的通用寄存器包括：eax、ebx、ecx、edx、esi、edi、ebp等。其中，eax常用于存储函数返回值，ebx、ecx、edx常用于传递函数参数和临时存储，esi和edi常用于数据传输和操作(源操作数和目的操作数)。

esp是堆栈指针，用于显示栈顶的地址。

esi寄存器（Extended Source Index）被广泛用于源操作数的传输。例如，在字符串操作指令（如movs、lods、cmps等）中，esi通常用于存储源字符串的地址。通过esi寄存器，可以方便地访问源操作数，并将其传输到其他寄存器或内存位置。

edi寄存器（Extended Destination Index）则通常用于目的操作数的传输。在字符串操作指令中，edi用于存储目的字符串的地址。通过edi寄存器，可以将数据从源位置复制到目标位置，或者将计算结果存储到目标位置。

#### 累加寄存器

它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。

#### 程序状态字寄存器PSW

保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OP)、符号标志(SF)、零标志（ZF)、进位标志(CF）等。PSW中的这些位参与并**决定微操作的形成**。

#### 移位器

对运算结果进行移位运算。

#### 计数器

控制乘除运算的操作步数。

### 控制器的基本结构

#### 程序计数器

用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能。

#### 指令寄存器

用于保存当前正在执行的那条指令。

#### 指令译码器

仅对操作码字段进行译码，向控制器提供特定的操作信号。

#### 微操作信号发生器

**根据IR的内容(指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号**，其结构有组合逻辑型和存储逻辑型两种。

根据时序信号，来判断是否进行下一条指令。更PSW的内容，来判断指令执行什么微操作。

##### 微命令和微操作

**微命令**是微操作的控制信号；而**微操作**是微命令的执行过程(实现)。

**微命令是控制序列的最小单位。**

微命令之间具有相容和互斥之分：

相容表示微命令对应的微操作可在同一个节拍中执行。(如：指令的执行过程中数据流仅CPU内部的寄存器之间)

互斥表示微命令对应的微操作不可在同一个节拍中执行。（如：指令为访存指令，其系统总线传输速度远不如片内总线传输）

#### 时序系统

用于产生各种时序信号，它们都是**由统一时钟(CLOCK）分频得到。**

#### MAR

用于存放所要访问的主存单元的地址。

#### MDR

用于存放向主存写入的信息或从主存中读出的信息。

### 总结

可见：可编程修改。对用户透明：用户不可被修改。

#### 用户可见寄存器：

<u>程序计数器PC，程序状态字寄存器PSW，通用寄存器组。</u>

#### 用户不可见寄存器：

MAR、IR、MDR、暂存寄存器。

#### 专用寄存器：

专用寄存器不可被通用寄存器替换，具有专门功能的。

程序计数器PC、存储器地址寄存器MAR、存储器数据寄存器MDR、程序状态字寄存器PSW、指令寄存器IR。

### 图示

![image-20230710231557543](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230710231557543.png)

在使用数据总线进行CPU外部数据传输至CPU内部寄存器时，我们通常将控制信号端口的编码带有E，如MDRinE来表明此控制端口输入的数据来至数据总线。

## 管理多条通路方式

### 多路选择器

多路选择器根据控制信号选择线路进行输出。

![image-20230710225539859](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230710225539859.png)

### 三态门

使用三态门，控制每一条连接线路是否输出。如下图，当R0out=1时，R0的数据输出到A端。当R0out=0时，R0的数据不进行输出。即对应寄存器的输出端的信号是否为高电平决定是否输出。

![image-20230710225358147](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230710225358147.png)

## 指令执行过程

### 指令周期

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间。一个指令周期包含若干个机器周期。

#### 机器周期： 

由若干个时钟周期组成。通常来说一个指令阶段是一个机器周期。

#### 时钟周期：

也称节拍，T周期或CPU时钟周期，信号脉冲。

#### 定长的机器周期

每个指令周期的机器周期数相同，或者机器周期的时钟周期数相同。

![image-20230711002459150](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711002459150.png)

#### 不定长的机器周期

每个机器周期的时钟周期个数不同。

![image-20230711002557694](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711002557694.png)

![image-20230711003000157](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711003000157.png)

就算是执行的空指令，程序计数器PC也需要自动+“1”指向下一条指令。

#### 间接寻址的指令周期

需要将地址码转为有效地址。

![image-20230711003053529](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711003053529.png)

利用触发器FE、INC、EX、INC可判断当前执行到的阶段。

取指周期的英文全称为 "Instruction Fetch Cycle"。 间指周期的英文全称为 "Instruction Decode Cycle"。 执行周期的英文全称为 "Execution Cycle"。 中断周期的英文全称为 "Interrupt Cycle"。

##### 四个周期的访存目的：

取值周期是取指令；间址周期是为了获取有效地址；执行周期是取操作数；中断周期是为了保护程序断点。

中断周期中的进栈操作是将SP减一。

![image-20230711003251517](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711003251517.png)

### 指令周期的数据流

#### 取指周期

根据程序计数器的指令地址，获取指令存放于指令寄存器中。

 ![image-20230711003416671](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711003416671.png)

<font color=red>需要注意的是：当取指完成时，PC是默认自动加1的</font>。

#### 间址周期

根据指令寄存器的地址码，获取到操作数的有效地址。

![image-20230711003600570](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711003600570.png)

#### 执行周期

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

#### 中断周期

保存断点处指令，传输中断向量和处理中断请求。

1.将栈顶指针减一，且SP地址传输给MAR，将表明SP的地址中的数据块将要保存当前PC中的指令地址。

2.控制单元发出写控制信号给主存，表明要进行的操作。

3.将PC中的指令地址发送至MDR，使其被保存在主存中。

4.将执行中断服务程序中的指令序列。

![image-20230711004238565](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230711004238565.png)



### 指令执行方案

#### 单指令周期

即每条指令占用一个时钟周期，指令之间串行执行。（上一条指令执行完毕后，下一条指令才启动）。

指令周期取决于执行时间最长的指令周期。

#### 多指令周期

指令也是串行执行，但是每个指令根据需求进行分配所需的时钟周期个数。

#### 流水线方案

每个时钟周期启动一条指令，尽量让多条指令在不同执行步骤中执行。

在某条指令的一个执行步骤中，其余指令处于不同的执行阶段中。

## 数据通路

数据在功能部件之间传输的路径称之为数据通路。包含数据通路上流经的部件：ALU、通用寄存器、标志寄存器、异常和中断处理逻辑等

### 数据通路的功能

用于CPU内部的运算器与寄存器之间或者寄存器与寄存器的数据交换。

### 数据通路的基本结构

#### 内部数据通路

将所有寄存器的输入端和输出端都连接到一条公共的通路上。

根据内部数据通路还可以细分为**内部单总线方式**和**内部多总线方式**。它们都是将控制信号的输入端和输出端都连接到通路。但区别就是：前者所有寄存器**只能连接在一条**公共通路上；而后者所有寄存器**可以连接多条**公共通路上。考试常考内部单总线方式。

在寄存器中，根据它的输出端Rxout和输入端Rxin的高低电平，来决定其端口是否输出和接受数据。

比如：Rxout=1时，输出数据；Rxin=1时，输入数据。

##### 特点

结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。

#### 内部单总线数据传输

##### 寄存器-寄存器

##### 主存-CPU

##### 执行算术/逻辑运算

在不同指令执行阶段，通过控制信号，生效寄存器的某些/个控制信号，从而实现数据的传输。

如下图：

![image-20230712004741682](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230712004741682.png)

根据上图，所需解释就是：

1. 我们在写出数据传输时，写出对应操作的同时，还需要写出**对应的控制信号信息**。
2. 在单内部总线中，我们利用ALU进行算术或逻辑运算的时候，需要知道要将其中一个数，提前传输至Y暂存寄存器，因为ALU需要输入端同时传输数据。



#### 专用数据通路

 根据指令执行过程中的数据和地址的流动方向安排连接线路。

###### 特点

性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。

####  本节考点

考察各个阶段所执行的微操作，以及微操作在数据通路上对应生效的控制信号，需要能够写出。

细节：

在取指阶段执行完毕的同时：PC自动加1；微操作信号发生器的控制信号发出到对应通路也需要注意；在MDR控制信号中，若数据从数据通路传输，则控制信号名需要加上E：MDRoutE,MDRinE.

#### 例题：

##### 内部单数据通路的指令阶段的分析

![image-20230712010302677](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230712010302677.png)

![image-20230712010249825](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230712010249825.png)

###### 1.分析指令功能和指令周期

功能：((R0))+(R1)->(R0)

取指周期，间址周期、执行周期。

###### 2.写出各阶段的指令流程

1. 取指周期:公共操作(将当前PC中的地址对应的指令取出到IR中分析指令)

   | 时序 | 微操作                    | 有效控制信号       |
   | ---- | ------------------------- | ------------------ |
   | 1    | (PC)->MAR                 | PCout,MARin        |
   | 2    | M(MAR)->MDR<br />PC+1->PC | MARout,MemR,MDRinE |
   | 3    | (MDR)->IR                 | MDRout,IRin        |
   | 4    | 指令译码                  | -----              |

2. 间址周期：完成取数操作，在主存之中取出被加数，加数在寄存器R1中。

   | 时序 | 微操作      | 有效控制信号      |
   | ---- | ----------- | ----------------- |
   | 1    | (R0)->MAR   | R0out,MARin       |
   | 2    | M(MAR)->MDR | MemR,MARout.MDRin |
   | 3    | (MDR)->Y    | MDRout,Yin        |

3. 执行周期：完成算术运算，将结果存放在主存之中。此时MAR中仍保存间址周期中R0的间接地址。

   | 时序 | 微操作        | 有效控制信号                            |
   | ---- | ------------- | --------------------------------------- |
   | 1    | (R1)+(Y)->Z   | R1out,Yout,ALUin,CU向ALU发出ADD控制信号 |
   | 2    | (Z)->MDR      | Zout,MDRin                              |
   | 3    | (MDR)->M(MAR) | MemW,MDRoutE,MARout                     |

##### 专用数据通路的指令阶段的分析

![image-20230712174037976](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230712174037976.png)

![image-20230712174119129](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230712174119129.png)

![image-20230712174057131](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230712174057131.png)





### 选择题总结

不同长度的指令的取指操作不同。

**指令字长与字节或存储字长（存储器）是整数倍关系。而指令字长与机器字长（数据总线）无关。**

**就算是空操作指令执行，程序计数器PC也会自动加1.**

<font color=red>存储器**进行一次**读或写操作所需的时间称为存储器的**访问时间**，而连续启动**两次独立**的读或写**操作**所需的最短时间称为**存取时间**。</font>

## 控制器设计

根据控制器产生微操作控制信号的方式不同，控制器可分**硬布线控制器**和**微程序控制器**。

这两种控制器的区别：指令执行步骤不同和给出控制部件的控制信号的方案不同。

### 硬布线控制器

控制器通过操作码字段的输入和时钟配合产生不同的控制信号；

时序控制的一个时序脉冲使控制单元传送一个或一组微操作命令(一个节拍可多个微操作)；

执行单元的反馈信息为标志。通过CPU当前所处状态而产生控制信号(也就是通过程序状态字寄存器来产生)。

**控制单元还接受系统总线中传输的控制信号：中断请求和DMA请求。**

#### 理解硬布线控制器工作原理

<font color=red>从指令操作码、目前的机器周期、节拍信号、机器状态条件可确定当前节拍下应发出的“微命令”。</font>

![image-20230713200532034](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713200532034.png)



从上图的左上角可知：微命令可由逻辑表达式描述。

#### 举例：M(MAR)->MDR微操作命令的逻辑表达式

![image-20230713204209639](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713204209639.png)

紫色为机器周期的触发器控制信号，T为节拍信号，蓝色为操作码译码器给出的控制信号，利用逻辑表达式构建的电路，其逻辑电路输出的信号为CU发出的微操作控制信号。

#### 硬布线控制器设计

通过以下介绍的设计步骤，我们可以更好的了解，控制器所需组件和输入和输出信号的通路。

![image-20230713204910712](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713204910712.png)

![image-20230713222523380](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713222523380.png)

##### 分析指令执行每个阶段的微操作序列

也就是将每个阶段的微操作写出来。

![image-20230713222653401](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713222653401.png)

##### 选择CPU的控制方式



##### 安排微操作时序

将每个周期的微操作根据安排原则，在不同的节拍安排执行。

###### 安排原则

原则一

微操作的先后顺序不得随意更改

原则二

被控对象不同的微操作，尽量安排在一个节拍内完成，

原则三

占用时间较短的微操作，尽量安排在一个节拍内完成并允许有先后顺序

<font color=blue>在微操作执行过程中，数据流通在寄存器之间，因为传输速度快，所以可以安排在同一个节拍中。而访问主存的指令，则不必要安排在寄存器中。</font>

###### 例如：执行周期

![image-20230713221034663](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713221034663.png)



##### 电路设计

在电路设计中，需要按以下步骤列出对应所需信息。

###### 列出操作时间表

根据之前分析指令的不同阶段的微操作和安排微操作时序的结果后，列表填入。1为在该指令中此阶段和节拍会执行。

如图：

![image-20230713223443672](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713223443672.png)

###### 写出微操作命令的最简表达式

在操作时间表中，选择某一微操作，从各个阶段中划出，哪些指令会执行。并列出表达式

如下图

![image-20230713224833121](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713224833121.png)

###### 画出逻辑图

根据逻辑表达式，画出该微操作执行，硬布线控制器的逻辑图：

![image-20230713224933516](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713224933516.png)

#### 非访存指令

CLA，COM，SHR，CSL，STP

#### 访存指令

ADD、STA、LDA、JMP、BAN

#### 硬布线控制器的特点：

随指令越多其设计实现越复杂，一般用于RISC。

当需要扩充一条新指令时，控制器需要大幅修改。

但因为硬布线控制器由纯硬件实现，所以执行速度很快。

**且微操作控制信号由组合逻辑电路即是产生。**



### 微程序控制器



#### 基本原理

##### 微程序

微程序是实现指令功能的抽象。一条指令的功能由一段微程序解释。而微程序由微指令组成。

微程序个数=机器指令个数+取指、间址、执行、终端周期等公共的微程序的个数。

##### 微指令

结合程序与指令的关系。一个微程序具有多个微指令，而一个微指令具有多个微操作，微指令是对微程序的实现，而微程序是机器指令的解释。

指令是对程序执行步骤的描述；而微指令是对指令执行步骤的描述(因为由微操作组成)。

所以指令是对微程序的封装。

且利用存储程序的思想，CPU在出厂前就已经将**微程序**封装于**控制器存储器**中。

**微命令与微操作一一对应；而指令与微程序一一对应。**

##### 微指令格式

由操作控制和顺序控制组成。

操作控制：表示当前对应的若干个微操作的控制信号。

顺序控制：表示要执行下一条微指令的地址。

##### 微周期：

从控制器存储器CM取出一条微指令并执行相应微操作所需时间。**通常是一个时钟周期**。

![image-20230714003355322](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714003355322.png)

#### 基本结构

##### 控制存储器CM：

用于存放各种指令对应的微程序，是ROM实现。

而主存时存放的程序和数据。

##### 地址译码：

将地址码转化为存储单元控制信号。

##### CMAR(μPC)和CMDR(μIR)：

两者相当于普通控制器中的程序计数器和指令寄存器。

CMAR用于存放从CM中取出的微指令，**其位数与微指令字长相等**

CMDR由操作控制信号和下一条微指令地址组成，接收由微地址形成部件送来的微地址。

##### 微地址形成部件：

产生初始化微地址和后继微地址。例如：确定微指令P的首地址。

![image-20230714005453545](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714005453545.png)

#### 工作原理

在顺序逻辑中，其标志控制信号的输入，根据该信号来判断指令地址码中的寻址特征位判断是否跳过间址周期。以及根据中断信号判断是否进入中断周期。以及其他等等。

书中指:计算机执行机器指令的过程在微程序控制器下进行。

1. 在机器开始运行时，自动取指微程序的入口地址送入CMAR中，并从CM中读出相应的微指令，并送至CMDR。

<font color=red>取指微程序入口地址一般为控制存储器的地址0</font>。

2. 而其他机器指令执行，由机器指令传递操作码给微地址形成部件，产生微地址为该机器指令的所对应的微程序的入口地址，并送入CMAR中。

3. 依次从控制存储器CM中取出对应微程序的微指令并执行。

4. 当执行完毕后，重新取出下一个机器指令，并执行步骤从1开始。

![image-20230714010446543](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714010446543.png)

#### 高频考点

![image-20230714010909767](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714010909767.png)

通过工作原理小节中的图，不难免看出，其微程序由取指周期微程序和执行周期微程序组成，当机器指令有n条指令时，其至少有N+1个微程序/段。(因为机器指令都对应一个执行周期，而取指周期则都为公共部分为1个微程序段，所以是N+1个)。

#### 总结

![image-20230714005153570](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714005153570.png)



###  微指令设计

一般一个微命令对应一条输出线。

#### 相容性和互斥性

相容性微命令指微命令可并行完成。互斥性微命令指微命令不可并行完成的微命令。

#### 微指令格式

##### 水平型微指令

一条微指令对应多个微命令

![image-20230714145833775](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714145833775.png)

##### 垂直型微指令和混合型微指令

一条微指令对应一个微命令。

![image-20230714145856299](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714145856299.png)

常考水平型和垂直型。

#### 水平型微指令的编码方式

##### 直接编码（直接控制）方式

微指令由操作控制和下地址组成。操作控制中的一个位代表一个微操作命令，当该位为“1”时，则其表示的控制信号有效。

![image-20230714151314520](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714151314520.png)

##### 字段直接编码方式

将操作控制划分为多个字段，而每个字段也进行编码，每一个编号为一个控制信号。例如：当一个字段为3位时，001经过译码后为1，其表示的微操作：(PC)->MAR生效。

需要注意的是：

<font color=red>具有相容性的微操作在不同字段中，而互斥性微操作在同一个字段内。一个字段信息位不可过多，以及一个字段必有一个状态被保留：比如译码后为0编号的状态，表示为不操作。</font>

![image-20230714151421319](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714151421319.png)

优点：

可以缩短微指令字长。

缺点：

要通过译码器译码后才能发出微命令。比直接编码方式慢。

##### 例题：

由例题可看出直接编码方式和字段直接编码方式的区别。

![image-20230714152432620](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714152432620.png)

##### 字段间接编码方式

是指，某一字段经过译码器后，其微命令还需要靠其他译码再次译码后才发出。

![image-20230714152800600](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714152800600.png)

#### 下一条微指令的地址形成方式

考试常考：下地址字段、计数器法、由硬件确定微程序入口法和操作码。

![image-20230714153300551](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714153300551.png)

通过测试网络：也就类似于顺序逻辑中，利用标志和CLK与CMDR决定执行下条微指令的位置。

#### 例题：

该题中，我们需要知道机器指令转微指令数计算中，常见的指令周期中我们不需要间址周期和中断周期，而只需要一个公共的**取指周期**和其余机器指令所转变为的**执行周期**，利用这两个周期数进行计算微程序数->微指令数。

![image-20230714154144462](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714154144462.png)

#### 总结

![image-20230714154126376](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714154126376.png)



### 微程序控制单元的设计

#### 步骤

![image-20230714162945636](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714162945636.png)

#### 分析微操作序列

![image-20230714160519486](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714160519486.png)

在微程序控制器的取值周期中，<font color=red>**最后一个微操作是将当前指令的操作码发送给微地址形成部件，得到该指令的微程序的起始地址。**</font>

<font color=red>**我们利用Ad(CMDR)->CMAR微操作， 将下地址发送到下一个执行节拍的微指令中**。</font>

![image-20230714161511663](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714161511663.png)



#### 扩展：

##### 静态微程序设计和动态微程序设计

###### 静态 

微程序无需改变，采用ROM

###### 动态

Intel芯片采用该方式，通过改变微指令和微程序改变机器指令，有利于仿真，采用EPROM。

##### 毫微程序设计

也就是在微程序设计的基础上，利用毫微程序解释微程序。(套娃行为)

#### 硬布线控制器和微程序控制器比较

![image-20230714163708310](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714163708310.png)

### 微程序控制器总结

红框为常考点。

![image-20230714163926122](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230714163926122.png)

## 从高级语言到指令执行

![image-20230713165322958](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230713165322958.png)



控制器根据指令操作码，通过指令周期不同阶段的寄存器获取的当前机器周期，节拍信号和机器状态条件(比如：PSW中标志符ZF,OF,SF,CF)，来确定当前节拍所需发出的微操作。

一个微命令对应一个微操作，微操作是对当前指令执行所需功能的解释，而微命令是使微操作所需部件生效的控制信号。

在专用数据通路中，寄存器之间有多种并行通路，所以同一个节拍(时钟周期)中可以进行并行操作。

通过指令的最长机器周期，来确定定长机器周期的节拍数。若某个执行周期所需的微操作较少，则安排在机器周期的末尾节拍中进行。

### *选择题总结

1. 微指令结构设计的目的是：提高执行速度，提高微程序设计的灵活性，缩短微指令字长。

2. 硬布线控制器的指令是控制器中的逻辑电路；而微程序控制器是控制存储器中的微程序。

3. 从时序系统视角看：1）硬布线控制器需要根据所有微操作综合分析，通过微操作的逻辑表达式，再设计电路。2）而微程序控制器的微指令是根据微程序保存在控制存储器中，且按照微程序中的微指令顺序执行即可。
4. 计算机也可分为控制部件和执行部件两大部分，控制部件由控制器组成；而执行部件由运算器、存储器、外围设备。



### *简答题总结

1. 可判定的外部条件有两个,其条件测试位为2，是因为还包含了无条件转移的情况。
2. 水平型微指令的操作控制的字段直接编码方式中，一个字段中必包含了未操作状态。
3. 对于像取指周期中的微命令，其属于公共微命令，在计算微命令个数时，需要注意。
4. 和机器字长=存储字长有关的寄存器有：ALU、ACC、X、MQ、IR、MDR；而和地址总线长度相关的寄存器是：PC和MAR。
5. 对于微程序的取指周期和执行周期的微命令，相对于普通的取指周期和执行周期，要多执行两条微命令：1）用于微指令循环的微操作：Ad(CMDR)->CMAR；2)用于下一个新微程序段的起始地址（或者叫微程序控制器的入口）。

## 指令流水线

### 基本概念

一条指令的执行过程可以分成多个阶段（或过程）。根据计算机的不同，具体的分法也不同。

#### 顺序执行方式：

![image-20230715002940032](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715002940032.png)

#### 流水线方式

##### 重叠执行方式

![image-20230715003159081](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715003159081.png)

考试常考指令执行为五个阶段的流水线。

#### *流水线的表示方法

##### 指令执行过程图

![image-20230715003448809](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715003448809.png)

##### 指令执行时空图

![image-20230715003505462](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715003505462.png)

#### **流水线的性能指标

##### 吞吐率

######   公式和定义![image-20230715004127794](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715004127794.png)

###### 图示

![image-20230715004227224](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715004227224.png)

###### 装入时间

是指部件逐步执行指令。

###### 排空时间

是指部件逐步退出指令执行。

##### 加速比

完成同样一批任务，**不使用流水线所用的时间与使用流水线所用的时间之比**。

###### 公式

![image-20230715004508888](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715004508888.png)

###### 图示

![image-20230715004559591](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715004559591.png)

##### 效率

设备忙的时间占总时间的比率。 

###### 公式：

![image-20230715005322057](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715005322057.png)

###### 图示

![image-20230715005337847](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230715005337847.png)

左边k个阶段完成时间，可填补右侧所差时间。这样只方便计算。

### 影响因素和分类

![image-20230716110441760](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716110441760.png)

需要理解各个阶段的部件执行，其数据流流向锁存器和下一个阶段的意义。

#### 结构相关(资源冲突)——互斥

由于**多条指令在同一时刻争用同一资源而形成的冲突**称为结构相关。

反相关性：前者指指令A需要操作的寄存器r在指令B操作寄存器r之前。（若交换指令顺序将影响寄存器中的数据）

输出相关性：指令A和指令B都需要对寄存器r进行操作。 （所以如果也交换位置，也会更改寄存器正常输出值）

如下图：

![image-20230716151215983](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716151215983.png)

##### 解决办法

1. 后一相关指令暂停一周期
2. 资源重复配置：将上图形式的存储器拆分为：数据存储器和指令存储器，更改后如下图：

![image-20230716151409718](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716151409718.png)

#### 常考*数据相关(数据冲突)——同步

数据相关指在一个程序中，**存在必须等前一条指令执行完才能执行后一条指令的情况**,则这两条指令即为数据相关。

如下图：sub,and,or指令会引起冲突。

![image-20230716152556590](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716152556590.png)



##### 解决方案：

1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期,直到数据相关问题消失后再继续执行。可分为**硬件阻塞**(stall)和**软件插入“NOP”(空操作)**两种方法，如下图：

###### 硬件阻塞

![image-20230716152737135](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716152737135.png)

###### 软件插入，nop空指令

![image-20230716152822753](../../../../AppData/Roaming/Typora/typora-user-images/image-20230716152822753.png)

2. 数据旁路技术：在ALU计算后，就直接把计算结果传入到下一个指令的ALU一个输入端中，如下图：

![image-20230716152437585](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716152437585.png)

3. 编译优化：通过编译器调整指令顺序来解决数据相关。比如类似于软件插入方法，将后续不使用会引起数据冲突的指令中寄存器的指令，调用合适条这种指令在冲突之间，如下图：

![image-20230716152525339](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716152525339.png)

#### 控制相关(控制冲突)

当流水线遇到**转移指令和其他改变PC值的指令而造或断流**时，会引起控制相关。比如：条件跳转、函数调用、函数返回和中断请求。其实就是：指在指令执行时，会因为控制操作导致流水线执行的中断并重置执行另一条指令载入流水线中。

例如跳转指令，当进行到中途，程序计数器的地址直接跳转到1000，则跳处至1000地址处的空间会冲突，如下图：

![image-20230716153103312](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716153103312.png)

##### 解决方案

1. 转移指令分支预测。简单预测（永远猜ture或false) 、动态预测(根据历史情况动态调整)

2. 预取转移成功和不成功两个控制流方向上的目标指令

3. 加快和提前形成条件码（类似于第二章的加法器设计中，将低位的进位提前计算传入高位加法器中）

4. 提高转移方向的猜准率

5. CSAPP中指出，有两种方式优化：1）条件转移策略：将if判断的表达式提前计算(例：for内部if往外提)。2）为控制转换：将for内部的if写成条件表达式。

### 五段式指令流水线

流水段的长度以最复杂的操作所花的时间为准。也就是以花费时长最长的阶段的时间作为所有阶段的机器周期时间。

虽然流水线方式不能缩短单条指令的执行时间，但对于整个程序来说，执行效率是得到提高的。

##### 缓冲寄存器（锁存器）

保存本流水段的执行结果，提供给下一流水段使用。

#### 流水线的数据通路

IF段中包含程序计数器PC、指令存储器、下条指令地址的计算逻辑。

ID端包含操作控制器、去操作逻辑、立即数符号扩展模块。

EX段包含ALU、分支地址计算模块。

M段包含数据存储器读写模块。

WB段包含寄存器写入控制模块。

#### 流水线的执行过程

##### 取指IF

##### 译码/读寄存器ID

##### 执行/计算地址EX

##### 访存MEM

##### 写回WB

### 考试常考五类指令分析

基于五段式指令流水线：IF取指，ID译码，EX执行，M访存，WB回写。

![image-20230716161605331](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716161605331.png)

#### 运算类指令

从下图可看出，在运算类中，其在M访存阶段是不进行任何操作的，其EX锁存器的数据直接传输到M的锁存器，等待指令执行到WB写回阶段。

![image-20230716164643858](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716164643858.png)

#### LOAD指令

在下图我们可知，LOAD指令在执行过程中，是需要访存的，其执行阶段的ALU用于计算地址。

![image-20230716164946991](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716164946991.png)

#### STORE指令

在下图我们可知，STORE指令在执行过程中，在M访存时是将数据写入Cache，而不是在WB段进行写回，一方面是因为降低数据冲突事件的发生，另一方面是因为由前面存储器章节中，我们可知Cache作为主存的数据块的副本，用于响应CPU能够快速获取数据。

![image-20230716171051732](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716171051732.png)

#### 条件转移指令

如下图所示：转移类指令的地址计算方式是相对寻址(即当前PC的下一条指令+偏移量为目的地址)，**在很多教材中把写回PC的功能称为"WrPC段"**，通常条件转移指令在M段中执行它，**所以条件转移指令不需要在WB阶段进行操作**。

![image-20230716172059890](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716172059890.png)

#### 无条件转移指令

如下图所示：其WrPC段在EX中执行，以避免控制冲突。

![image-20230716172843389](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716172843389.png)



### 流水线分类

#### 按使用级别分

##### 部件功能级

部件功能级流水就是**将复杂的算术逻辑运算组成流水线工作方式**。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。

##### 处理机级

处理机级流水是把**一条指令解释过程分成多个子过程**，如前面提到的取指、译码、执行、访存及写回5个子过程。

##### 处理机间

处理机间流水是一种宏流水，其中**每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中**。

#### 按完成功能

##### 单功能

单功能流水线指只能实现**一种固定的专门功能**的流水线。比如：只完成浮点数加法的流水线。

##### 多功能

多功能流水线指通过**各段间的不同连接方式可以同时或不同时地实现多种功能**的流水线。比如：指令流式线

#### 按连接方式

##### 动态

动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。例如：ALU中只能同一时间内执行浮点数加法

##### 静态

静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。例如：ALU中只能同一时间内可以执行多种浮点数运算

#### 按有无反馈信号

##### 线性

线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。

##### 非线性

非线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。例如：ALU的输出信号作可作为自身的输入信号(数据旁路技术)。



### 流水线多发技术

#### 超标量流水线技术

也称动态多发射技术，**每个时钟周期内可并发多条独立指令，以并行操作方式将多条指令编译并执行，需要配置多个功能部件**。

通过动态分支预测等手段，指令不按顺序执行，为乱序执行。空分复用

![image-20230716154020447](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716154020447.png)

#### 超长指令字长技术

也称静态多发射技术，由编译程序分析指令间潜在的并行，并将多条能够并行的指令组合成一条具有多个操作码字段的超长指令字。

  

#### 超流水线技术

提高流水线主频的方式，来提升流水线性能。当流水线技术增加，其时钟周期变短，吞吐率提高，但用于流水线寄存器的开销也增加。

超流水线CPU在流水线充满后，每个时钟周期执行一条指令，CPI=1,但此时主频更高。

而多发射流水线CPU的每个时钟周期可以处理多条指令，CPI<1，但成本更高，控制更复杂。

**时分复用技术，也就是一个时钟周期内再分段(图中再分3段)，指一个时钟周期内一个功能部件使用多次(图中3次)**。

![image-20230716154206239](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716154206239.png)

## 多处理器系统的基本概念

### SISD、SIMD、MIMD的基本概念

#### 单指令流单数据流SISD结构

![image-20230716230746290](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716230746290.png)

#### 单指令流多数据流SIMD结构

![image-20230716230739091](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716230739091.png)

#### 多指令单数据流MISD结构

多条指令并行执行，处理同一个数据。现实中不存在这种计算机

#### 多指令流多数据流MIMD结构

 ![image-20230716230508080](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716230508080.png)

![image-20230716230419348](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716230419348.png)



##### 多处理器系统

![image-20230716230638325](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716230638325.png)

##### 多计算机系统

![image-20230716230650562](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716230650562.png)

##### 运用类型

###### 向量处理器

是SIMD的变体。

![image-20230716231812518](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716231812518.png)

![image-20230716233203449](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716233203449.png)

###### 多核处理器的基本概念

![image-20230716233249737](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716233249737.png)

###### 共享内存多处理器的基本概念

统一存储访问UMA多处理器：每个处理器访问所有的存储单元的访问时间大致相同，与处理器提出的访存请求和访问字的类型无关。

非统一存储访问NUMA多处理器：访问速度具体取决于哪个处理器提出了访问请求以及访问那个字。原因是：主存的部分数据被复制在CPU内部寄存器中。

![image-20230716233436801](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716233436801.png)

### 硬件多线程的基本概念

#### 考点：

![image-20230716232713883](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230716232713883.png)

#### 细粒度多线程

多个线程之间轮流交叉执行指令，多个线程之间的指令是不相关的，可以乱序并行执行。处理器能在每个时钟周期切换线程。

#### 粗粒度多线程

仅在一个线程出现了较大开销的阻塞时，才切换线程，如Cache缺少。

#### 同时多线程（SMT）

是上述两种技术的变体。实现了指令级并行的同时，实现线程级并行。也就是说同一个时钟周期内，发射多个不同线程中的多条指令执行。



### 选择题总结

1. 超线程技术是在一个CPU中，提供两套线程处理单元，让单个处理器实现线程级并行，共享CPU的高速缓存和功能部件。
2. **双核技术是将两个一样的CPU集成封装在内**；而**超线程技术**是在CPU内部仅复制必要的线程资源来让两个线程同时运行，能并行执行两个线程，**模拟实体双核心**。
3. 时间并行是流水线技术，空间并行是硬件资源的重复，也就是并行机：SIMD和MIMD
4. 在UMA架构中若使用了共享存储器方式，则在Cache中内容一致性问题，不仅是第三章的Cache与主存的一致性，还有CPU内部Cache内部之间内容的一致性问题。
5. 多核上的多线程是物理层上的并行；而单核上的多线程是模拟方面，多线程交错执行。
6. Intel的超线程技术就是同时多线程SMT，即在一个单处理器或单核中设置了两套线程状态部件，共享高速缓存和功能部件。

# 指令系统(考纲为X86指令集)

## 什么是指令

指令就是计算机执行的命令。计算机运行的最小功能单位。

由前面的学习可知：指令由操作码和地址码组成，以及前面我们所学习的指令通常表示为一地址指令，其中的操作数就是地址码。同理：n地址指令结构为：<font color=red>一个操作码和n个地址码(以及地址码对应操作数)</font>。

## 操作数和地址码

<font color=blue>地址码只是指向操作数的一个地址或位置，但操作数本身可能是数据或地址</font>。并且需要知道的是，根据不同体系结构和指令集，其**地址码长度不一定等于操作数长度**，地址码可能还包含了指向操作数的地址，以及还包含有标志位和寄存器索引等。

**指令字长取决于操作码的长度、操作数地址码的长度和操作数的个数。**指令字长与机器字长没有绝对关系。

在考纲书中，一般单字长度为32位，半个字为16位。不过字长具体长度得看机器字长。



## 什么是指令集(指令系统)

指令集是指令构成的集合。也称**指令系统(ISA)**。

指令系统是指令系统体系结构中最核心的部分，ISA完整的定义了**软件和硬件之间的接口**。

ISA规定的内容主要包括了：指令格式，数据类型和格式，操作数的存放方式，程序可访问的寄存器个数、位数和编号，存储空间的大小和编址方式，寻址方式，指令执行过程的控制方式等。

在黑皮书中，ISA：RISC-V中，通常为三地址指令（存储指令的格式 sd 要写回寄存器地址 被写回寄存器地址）。而Intel通常为二地址指令。

#### 对齐限制：

在许多体系结构中，字的起始地址是4的倍数，而双字的起始地址必须是8的倍数。**即数据在内存中要与自然边界对齐的要求。**



## 指令格式

记忆,从结构上进行：指令可按指令长度、操作数(地址码)个数、操作码长度和操作码类型进行分类

### 按操作数(地址码)个数分类

![image-20230703155155922](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703155155922.png)



#### 零地址

堆栈计算机的操作数隐藏在栈顶和栈底中，不会显式显示在栈帧中。

![image-20230703155934071](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703155934071.png)

#### 一地址指令

![image-20230703155857683](../../../../AppData/Roaming/Typora/typora-user-images/image-20230703155857683.png)

OP(操作数)：表现的是操作数执行操作码对应的操作。

(地址)获取的：获取的是地址对应的内容，而地址中可以为寄存器或操作数(因为数据和地址以同等地位存放在操作数中)。

#### 二地址指令

![image-20230703160242350](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703160242350.png)

#### 三地址指令

![image-20230703160258824](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703160258824.png)



#### 四地址指令

![image-20230703160406740](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703160406740.png)

#### 地址码位数的影响

n位地址码的直接寻址范围为$2^n$个，当指令总数总长度固定不变(即地址总线宽度不变)时，地址码数量越多，寻址能力越差。

### 按指令长度分类

#### 指令字长

一条<u>指令的长度</u>（可能会变）。

##### 定长指令字结构

指令系统中所有指令的长度相等。**指令字长=存储字长**。

##### 变长指令字结构

指令系统中所有指令的长度可变。

当指令字长长于存储字长时，根据编制是按字节或字方式，从而确定变长指令字中每个指令，在程序计数器实际加多少值n。

![image-20230704131403071](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704131403071.png)

#### *机器字长

CPU进行一次整数运算所能处理的二进制位数，通常与CPU内部寄存器(ALU)的位数相关。

#### 存储字长

一个存储单元拥有的单存储元件的个数(即一串二进制多少位数)，通常与MDR相关。<u>即一个存储单元的长度。</u>

#### 指令字长和机器字长的关系

半字长指令、单字长指令，双子长指令，其中字的数量级是指令长度是机器字长的倍数。

例如：假设机器字长为32 bit,则单字长指令为32bit，双字长指令为64bit，我们取一条双字长指令需要两次访存操作。

#### *数据字长

联合主存数据块理解，表明能从数据总线一次传输的二进制的位数()。

#### 存储字长

即存储单元的一串二进制位数。

### 按操作码长度分类

![image-20230703163223852](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703163223852.png)

扩展操作码指令格式：指指令长度不变，但是操作码长度可变。

#### *扩展操作码

![image-20230703165931593](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703165931593.png)

即上图表示是：当扩展操作码时，前一个操作码需固定全为1(类似计网的可变长掩码)。<u>n个1111作为n地址扩展操作码之用。</u>

##### 注意：

在设计扩展操作码指令格式时，必须注意以下两点:（结合哈夫曼编码的“前缀编码”理解）

1) 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
2) 各指令的操作码一定不能重复。

通常情况下，**对使用频率较高的指令，分配较短的操作码**;对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

#### 题目

![image-20230703180306327](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703180306327.png)

地址长度为n，是指操作数或地址码的位数为n。m为上一层留下的操作码状态剩余数。状态数从操作数编码除去最低有效位部分后的剩余位看。

此类题设计指令系统，且每一部分的地址指令要求不同，从上图中可以看出，操作码的前缀全为1是下一层地址的操作码的起始位置。（**为什么：短的操作码不能是长的操作码的前缀，原因：霍夫曼前缀编码的要求）。**

<font color=blue>这类题的理解可以从哈夫曼编码的前缀形式理解，或者说从计网的可变长掩码做题方法理解。</font>

#### 操作码分类总结

![image-20230703182515270](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703182515270.png)

#### *X86指令集

X86指令集采用变长指令格式，其中指令的长度可以根据需要而变化，其中的操作数可以变为8\16\32\64位，而地址码用于指定操作数的存储位置或操作数的偏移量。

### 按操作类型分类

![image-20230703162912246](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230703162912246.png)

#### 1.数据传输类

load 加载：把数据从存储器加载到寄存器

store 存储：把数据从寄存器存储到存储器

#### 2.运算类

算术运算和逻辑运算，移位操作。

#### 3.程序控制类

即改变程序执行指令顺序，例如：跳转指令：JMP,Jne，je；以及调用命令call和返回指令return。

#### 4.输入输出操作

CPU与I/O设备之间的数据传输，通过I/O总线通过设备的I/O接口进行数据交换。

#### 调用指令和转移操作的区别：

调用指令执行时必须保持下一条指令的地址(即返回地址)，当子程序执行完毕时，会根据返回地址返回到主程序对应位置继续执行。而转移操作不执行返回。

条件跳转指令：je等于,jne不等于,jg大于,jl小于。jmp无条件转移。

## 寻址方式

寻址方式是指寻找指令或操作数有效地址的方式，解释：确定本条指令的数据地址，及下一条待执行指令的地址的方法。

##### 形式地址：

指令中的地址码不代表操作数的真实地址。

##### 有效地址：

即形式地址结合寻址方式，计算出操作数在存储器中的真实地址。

![image-20230704135611859](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704135611859.png)

### 指令寻址

下一条预执行指令的地址，始终由程序计数器PC给出。

<font color=blue>当指令按定长或变长结构时，根据编制方式，实际PC自动所加的偏移量是不同的(需要进行分析得出)。</font>

#### 顺序寻址

指PC程序计数器加”1“(偏移量)，来自动形成下一条指令。

##### **PC所需的偏移量

此处的“1”表示的是，当指令按定长或变长字结构时，其根据编制方式的不同，每一条指令顺序执行时，所需要的偏移数不同。“1”=一条指令字长/存储字长。如下图：当主存按字节编制时，一个指令所需的偏移量为2。

#### 跳跃寻址

通过转移类指令实现，即下一条指令地址的计算方式由本条指令给出。而跳跃的地址可分为绝对地址和相对地址。而是否可跳跃，由状态寄存器和操作数控制。

##### 绝对地址

能够由标记符直接得到。

##### 相对地址

通过当前指令地址的 偏移量来得到。

![image-20230704133056928](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704133056928.png)

指令的执行分为“取指令”和“执行指令”阶段。

当取一条指令结束后，PC会自动加上该指令所应有的地址偏移量，当执行指令时，如果为跳转指令，则会将PC的内容覆盖为跳转指令中的地址码的地址。

<font color=cblack>**简而言之，当指令执行时，程序计数器PC的值=PC+1，已经指向了顺序执行的指令。**</font>

对于变长指令通过操作码(中的最高位是否为1)确定是否为同一个指令。

### 数据寻址

确定操作数的真实地址。

##### 寻址特征：

用于确定该指令用何种寻址方式。在结构中寻址方式位。

##### 后续概念出现的符号注解

指令格式：操作码OP|寻址方式位|形式地址A。A为形式地址(不代表操作数的真实地址)，EA为有效地址(实际指向操作数的真实地址)。后续会使用。

<font color=blue>由指令结构可知一条指令由操作码和地址码组成。所以一个地址码不等于形式地址，地址码还可以包含多个信息位，比如：寻址方式位，位偏移，寄存器编号等</font>

### 普通数据寻址方式

#### 隐含寻址

指令不显式体现操作数，而是隐含在操作码或某个寄存器中，例如：当一地址进行算术加法时，ACC中本身已经还有数值了，这种就称之为隐含寻址。

##### 优点:

有利于缩短指令字长。

##### 缺点:

需增加存储操作数或隐含地址的硬件。

#### 立即数寻址

指令中形式地址部分存储的是立即数。A就是操作数。寻址特征值为"#"时，表示为立即数寻址。且数据用补码形式存储。

![image-20230704151114268](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704151114268.png)

#### 直接寻址

即形式地址中操作数的真实地址，即**EA=A**。缺点：A的位数决定了操作数的寻址范围，且不易修改(因为修改时需要直接法形式，指令的形式地址和主存的数据块都修改)。

![image-20230704144209346](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704144209346.png)

#### 间接寻址

操作数地址的地址，也就是说形式地址是存储的操作数在主存的间接地址，而这个间接地址存储的是操作数在主存的地址。符号化：**EA=(A).**

![image-20230704144355136](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704144355136.png)

##### 优点:

可扩大寻址范围(有效地址EA的位数大于形式地址A的位数)。比如：A为16位的地址，而EA为一个32位的地址。主存地址只是用于寻址数据块，其大小不等于数据块大小。

便于编制程序(用间接寻址可以方便地完成子程序返回)。即编程时，多个子程序之间进行调用。

##### 缺点:

指令在执行阶段要多次访存(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。

#### 寄存器寻址

形式地址保存的寄存器编码。通过访问寄存器得到地址。**EA=$R_i$**

![image-20230704150246305](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704150246305.png)

##### 优点

只在取指阶段访问主存，且形式地址位数少，从而指令字短，执行速度快。

##### 缺点

寄存器个数有限。

#### 寄存器间接寻址

![image-20230704150719721](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704150719721.png)



### 偏移量寻址方式

偏移量寻址方式的求址等式相同，通过对起点地址进行偏移。

只不过选择的偏移起点不同。下表：

| 寻址方式 | 选择的起始地址                          | 作用                         |
| -------- | --------------------------------------- | ---------------------------- |
| 相对寻址 | 选择PC所指地址为起点，$EA=(PC)+A$       | 将程序代码中的代码块进行浮动 |
| 基址寻址 | 以程序的起始存放地址为起点，$EA=(BR)+A$ | 将程序整体在内存中浮动       |
| 变址寻址 | 程序员自己决定起点，$EA=(IX)+A$         | 在代码内部建立循环           |

基址寻址与变址寻址的PC和形式地址的存储内容相反。

#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址,即EA=(PC)+A，其中A是相对于PC所指地址的位移量，可正可负，补码表示。

**当PC的指令取出后的同时，程序计数器就已经指向了下一条指令，PC=(PC)+"1"。**

**所以有效地址计算公式中A是相对于下一条指令地址的偏移量,而非正在执行的指令。**

![image-20230704165642353](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704165642353.png)

**相对寻址使用于程序内部的代码块在程序内部的浮动，适用于编制跳转指令。**

![image-20230704182453707](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704182453707.png)

相对寻址也就是用于解释部分代码块的逻辑位置。如下图：条件跳转指令与ACC加法指令相差4条指令。图中主存按字编制，则相差四个字。

![image-20230704182840842](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704182840842.png)

在程序的虚拟内存中，我们一般会分代码段、数据段、运行堆、共享库的内存映射区域、用户栈，内核的虚拟内存(物理内存，内核代码和数据，以及页表，task和内核栈等)。

#### 基址寻址

BR——base address register

基址寄存器可以专用或通用寄存器。我们需要注意的是：当基址寄存器为通用寄存器时，**用户可以决定使用哪个寄存器作基址寄存器**，**但是基址寄存器的内容由：操作系统和管理程序确定**，用户无法修改。所以就算用户使用了汇编语言编写，选择了某个寄存器作基址寄存器，但内容仍由操作系统管理。

**在通用寄存器方式中，通用寄存器构成了寄存器组，所以指令还需要几个二进制位表示基址寄存器号，从而确定基址寄存器位置。**

如下图所示：左边为专用寄存器，右边为通用寄存器。

![image-20230704161511319](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704161511319.png)

该方式用于解决程序逻辑空间与存储器物理空间的无关性。

如下图所示：程序内部指令的逻辑顺序不变，我们只需要更改程序指令的起始地址(也就是基址)即可。从而联想，内存中多个程序所处主存不同位置，但仍可正常执行。

![image-20230704162106630](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704162106630.png)

优点:可扩大寻址范围（基址寄存器的位数大于形式地址A的位数)；用户不必考虑自己的程序存于主存的哪一空间区域，故**有利于多道程序设计，以及可用于编制浮动程序（整个程序在内存里边的浮动/更改位置)。**[注：程序在内存中的浮动]

理解：基址寄存器BR的地址改变，则代表的指令块位置也随之改变。

#### 变址寻址

IX——index register，变址寄存器也可以是专用和通用，通用寄存器的所需要设置的情况同基址相同（增加寄存器号位）。

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA= (IX)+A，其中IX可为变址寄存器(专用)，也可用通用寄存器作为变址寄存器。

<font color=red>注意：</font>变址寄存器**面向用户**的，在程序执行的过程中，变址寄存器的内容**可由用户改变(<font color=red>IX作为偏移量</font>)**，**形式地址A不变(<font color=red>作为基地址</font>)**。

如下图：基址寻址和变址寻址的不同处：

![image-20230704163433369](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704163433369.png)

#####  举例

![image-20230704164337628](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704164337628.png)

所以可看出**变址寻址适合编制循环程序**（利用IX寄存器进行计数功能）。

#### 基址和变址复合寻址

在实际中，程序栈的起始位置不可能为0，所以还需要利用基址寄存器中的基址，从而加上变址的内部逻辑公式得到实际地址。$EA=(BR)+A+(IX)$。

程序基址=(BR)+A。偏移量=(IX)

![image-20230704164848417](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704164848417.png)

指令执行期间，访存次数总结：

![image-20230704182432918](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704182432918.png)

### 堆栈寻址方式

#### 堆栈寻址

操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。

在出入栈时，根据地址大小编号方向(大/小端编号)，入栈时需要将SP$\underline{+}$1。同理而在数据出栈之后，需要吧栈帧SP移动到当前堆栈顶位置。

1. 硬堆栈（Hardware Stack）：硬件堆栈：
   - 硬堆栈是由处理器硬件直接支持和管理的堆栈结构。
   - 在硬堆栈中，处理器会使用专门的寄存器（如栈指针寄存器）来跟踪堆栈的顶部。
   - 每当有函数调用或返回操作发生时，硬堆栈会自动处理堆栈指针的调整、参数的压栈和弹栈操作。
   - 硬堆栈通常是固定大小的，由硬件限制或者预先配置的。
2. 软堆栈（Software Stack）：软堆栈（Software Stack）：
   - 软堆栈是通过软件代码实现的堆栈结构，不依赖于硬件支持。
   - 在软堆栈中，堆栈的管理和操作是通过编程语言的指令来完成的。
   - 在函数调用和返回过程中，程序员需要手动管理堆栈的状态，包括参数的压栈和弹栈操作。
   - 软堆栈的大小和管理方式由编程人员自行决定，可以动态调整和扩展。

堆栈是存储器(或专用寄存器组)中一块特定的按“后进先出(LIFO)”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针(SP) 。

#### 专用寄存器组——硬堆栈

利用寄存器组成的堆栈，以及拥有一个栈指针寄存器。

![image-20230704193735223](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704193735223.png)



利用堆栈完成一次加法运算：先出栈取出两个数，然后再将运算结果入栈。

#### 软堆栈

利用主存的数据块实现堆栈，被称为软堆栈

![image-20230704194358024](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704194358024.png)

#### 堆栈在函数调用时，保存当前函数的相关信息有：

1. 返回地址（Return Address）：
   - 返回地址是指函数调用完成后需要返回到的下一条指令的地址。
   - 在函数调用时，将返回地址压入堆栈，以便在函数返回时可以从堆栈中弹出并跳转到正确的位置。
2. 前一个栈帧的指针（Previous Frame Pointer）：
   - 前一个栈帧的指针指向上一个被调用函数的栈帧，用于实现函数调用的链式结构。
   - 在函数调用时，将前一个栈帧的指针压入堆栈，以便在函数返回时可以从堆栈中弹出并恢复前一个栈帧的指针。
3. 本地变量和临时变量：
   - 在函数调用过程中，局部变量和临时变量通常存储在堆栈中的特定位置。
   - 在函数调用时，为局部变量和临时变量分配堆栈空间，并将其值保存在堆栈中。
   - 在函数返回时，将堆栈空间释放，并恢复之前保存的变量值

### 指令寻址总结

![image-20230704194816677](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704194816677.png)



### 硬件实现的比较（符号位）

![image-20230704184054245](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230704184054245.png)



也就是说通过处理器的状态寄存器里面OF、SF、ZF、CF的标志位，来进行计算cmp指令。

### 汇编基础

![image-20230707144853108](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707144853108.png)

### **机器级代码学习

在我的建议是结合CSAPP黑皮书进行学习，而笔记在《深入理解计算机系统》文章中。

此处仅作资料书的部分笔记。

408考试中，需要熟悉x86的AT&T和Intel的汇编格式。<font color=red>默认使用Intel格式</font>

#### *汇编转机器码



#### 在408题型中汇编语句

1.[寄存器]等价于。(%寄存器名)

![image-20230707151849226](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707151849226.png)

#### AT&T和Intel汇编格式区别

1. AT&T常用于Linux系统中，而Intel常用于Windows中。
2. 前者的立即数表示有"$"符，而后者没有。|\$4|4|
3. 前者表示寄存器须使用“%”，而后者没有。|%rdi|rdi|
4. 前者的操作数顺序为:源操作数，目的操作数；后者为目的操作数，源操作数.
5. 前者在内存寻址上为( rsp );而后者为[rsp].
6. 在具有偏移，比例寻址等情况时，前者为disp(base, index, scale),如：8(%rdx,%rax,2)——M[R[rax]+R[rax]*2+8]；而后者为[rax+rax\*2+8].
7. 在表示数据的长度上:AT&T在操作码后紧跟(b,w,l,q)；而后者需要显示标注为：byte ptr,word ptr,dword ptr,qword ptr.

![image-20230707155455546](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707155455546.png)

##### Intel格式偏移寻址格式理解

![image-20230707160258959](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707160258959.png)

#### (*须记住)常见的寄存器：

<font color=red>以i结尾的是变址寄存器，以x结尾为通用寄存器。变址和堆栈寄存器只能为32位或者64位，而通用寄存器可以指定8bit。</font>

1. 保存返回值`%rax`.

- `%rax` 是累加器寄存器（Accumulator Register），也称为返回值寄存器。它在函数调用过程中用于存储函数的返回值，也常用于存储中间结果、临时数据以及一些算术和逻辑运算。

2. 保存参数`%rdi`,`%rsi`,`%rdx`,`%rcx`,`%r8`,`%r9`.

- `%rsi` 是源索引寄存器（Source Index Register），也称为源操作数寄存器。它常用于存储源数据的地址，用于数据传输、字符串操作、循环等场景。例如，`movl (%rsi), %eax` 将从 `%rsi` 寄存器指定的内存地址中读取数据并存储到 `%eax` 寄存器中。
- `%rdi` 是目标索引寄存器（Destination Index Register），也称为目标操作数寄存器。它常用于存储目标数据的地址，用于数据传输、字符串操作、循环等场景。例如，`movl %eax, (%rdi)` 将 `%eax` 寄存器中的数据存储到 `%rdi` 寄存器指定的内存地址中。
- `%rcx`在 x86 汇编语言中，经常被用作循环计数器。它可以存储一个计数值，然后在循环中进行递减或递增操作，以控制循环的执行次数。

3. 调用函数的临时数据保存`%r10`,`%r11`.

4. 被调用函数临时数据保存`%rbx`,`%r12`,`%r13`,`%r14`.

5. 指令指针寄存器`%rip`（属于程序计数器）。

- `%rip` 存储了当前正在执行的指令的地址，也就是下一条将要执行的指令的地址。它在程序执行期间不断更新，指向下一条将要执行的指令。rip寄存器的内容有CPU自动维护，用户无法更改。

- 程序寄存器是处理器中的一组寄存器，用于存储与程序执行相关的信息，例如指令地址、指令计数器和程序状态等。这些寄存器用于跟踪和控制指令的执行，以及处理分支、函数调用、返回等操作。

#### 指令的长度表示

在x86指令集格式中16位二进制位=1字

例如：movl表示是移动四字节长度的指令。

|              | 字节    | 单字   | 双字   | 四字   |
| ------------ | ------- | ------ | ------ | ------ |
| 全称         | Byte    | word   | dword  | qword  |
| 指令显示后缀 | AT&T:无 | AT&T:w | AT&T:l | AT&T:q |

#### 常见算术运算指令

edx:eax表示两个寄存器连用，把被除数进行位扩展为64位。

![image-20230707154227157](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707154227157.png)

#### 逻辑运算指令

![image-20230707154813833](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707154813833.png)

#### 其余剩下指令

![image-20230707155004201](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707155004201.png)

#### 比较指令的符号位情况

PF表示为奇偶标志位。

![image-20230708132109549](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708132109549.png)

#### 转移指令

转移指令的使用前提：cmp r1,r2.将两数比较。

在AT&T格式下，实际等于r2-r1进行比较；而Intel格式相反，为r1-r2。

##### 无条件转移指令

![image-20230707181502643](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707181502643.png)

![image-20230707181549508](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707181549508.png)

##### *每个跳转对应判断的标志位

![image-20230707182923960](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707182923960.png)

SF==OF：即符号位与溢出位相同，表示没有有符号数溢出。

SF!=OF：即符号位不等于溢出位，表示有符号数溢出。

SF：取结果的最高位。

溢出：具有正溢出和负溢出。

写汇编代码时，一般使用函数作为标号，用于标号在跳转时的一个索引位。

执行转移指令后，PC中的内容就会被覆盖为目标地址。

#### *实现循环、

##### 条件转移实现

自己理解：参数初始化->是否可以提前结束(条件转移)->循环体->循环条件->循环跳出

![image-20230707225856820](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707225856820.png)

##### loop实现

```assembly
mov ecx, 10         ; 将 10 存储到 %rcx 中，作为循环的计数值

loop_start:
    ; 循环体代码
    ; ...

    loop loop_start  ; 循环回到 loop_start 标签处，继续执行循环体
loop loop_start 等价于:
 dec ecx#先自减
 cmp ecx,0#再与0比较大小
 jne loop_start#若不等于，则继续执行循环
```

loopx,此处的x可以用跳转的判断ne,e,z,nz替换

![image-20230707230553162](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707230553162.png)

#### *函数调用和返回

##### call和ret指令的作用

![image-20230707232430320](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707232430320.png)

call指令执行：

![image-20230706181500255](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230706181500255.png)



##### 访问栈帧数据

###### 栈帧结构：

![image-20230707234709834](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707234709834.png)

###### 访问数据pop和push格式

pop指令紧跟出栈内容的存放位置。

在x86中默认使用4字节为单位。

并且push 可以为立即数、寄存器、主存地址；pop 可以为寄存器和主存地址。

![image-20230707235154791](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707235154791.png)

###### 访问数据mov，add和sub方法

![image-20230707235920899](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230707235920899.png)

综上所述：访问栈帧数据可以使用pop和push组合，以及对栈指针进行偏移操作和mov移动值组合。

前者需要对压栈的元素在出栈时依次执行。而后者通过sub栈顶指针可扩展栈帧空间，而使用add缩小空间，以及使用mov对顶点偏移量位置的暑假进行替换。

###### 切换栈帧

![image-20230708003037596](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708003037596.png)

 **除了main函数，其他都是被调用函数。**

 <font color=red>在call指令执行时，会将原PC中保存的指令压栈，并指向被调用函数的第一条指令。然后在被调用函数栈帧中，因为栈结构，所以需要压入调用函数栈底的位置信息，来保存调用函数的信息。过后再通过mov完成被调用函数的栈顶指针和栈底指针初始化。再返回前，先将调用函数栈帧保存的信息回复：即移动栈顶指针于调用函数rsp<-rbp，恢复调用函数的栈底指针信息rbp<-(rbp)。最后执行ret指令，从栈顶找到返回地址。出栈保护call的指令。</font>

#### 栈帧实际运行

![image-20230708004722654](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708004722654.png)



##### 栈帧结构

![image-20230708005011718](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708005011718.png)

##### 函数调用的栈帧数据入栈

当一层函数调用执行时，

如果有使用到公共寄存器，则需要先将这些寄存器当前的值压栈，

然后将上一个栈帧的%ebp地址压栈，

然后再把局部变量压栈，

再然后把传递给函数所需形参的数据压栈。

最后才把call指令执行前，保存当前的IP(程序计数器)的地址。

另一种形式：![image-20230708130909485](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708130909485.png)

####  函数调用总结：

##### 汇编格式

![image-20230708115336570](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708115336570.png)

#####   思维导图



![image-20230708010849357](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708010849357.png)

调用函数和被调用函数在同一个内存条结构



### 阅读反汇编代码：

<font color=blue>汇编代码可以转变为机器指令</font>

阅读反汇编代码时，跳转指令的编码方式一般是相对寻址法。

在跳转指令后，一般紧跟的是指定指令的相对地址。 

```assembly
#本节截选CMU的CSAPP课程的Second lab: <Boom>——phase_1
0000000000400ee0 <phase_1>:#本段汇编代码的起始地址，以及标记位
 #单条反汇编代码格式：(基于X86_64指令集的AT&T格式)
 #虚拟地址	 机器指令				  指令    源操作码，目的操作码
  400ee0:	48 83 ec 08          	sub    $0x8,%rsp
  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi
  400ee9:	e8 4a 04 00 00       	callq  401338 <strings_not_equal>#调用两字符串是否相等函数
  400eee:	85 c0                	test   %eax,%eax#test指令，对自身进行and逻辑运算
  400ef0:	74 05                	je     400ef7 <phase_1+0x17>
  						#跳转指令：相对寻址：虚拟地址形式：400ef7，<phase_1+0x17>：标志+偏移量
  400ef2:	e8 43 05 00 00       	callq  40143a <explode_bomb>
  400ef7:	48 83 c4 08          	add    $0x8,%rsp
  400efb:	c3                   	retq   
```

#### 需要注意的地方

1. 有时候在跳转指令后，紧跟一个rep(repz) retq指令，其中rep(repz)仅表示为空指令用于捕获条件跳转指令目标，防止不属于分支语句的return指令被执行。

2. retq = ret，都是调用后返回指令。
3. 我们需要知道的是，在机器程序级的代码中，我们无法通过内存直接访问内存，而是通过内存-寄存器-内存的形式来访问。
4. 有时候我们会看见使用的是rbx的64位寄存器，但指令中使用的是它的32位形式ebx，则种情况下的意思就是，rbx的高32位为0，不参与运算。

​		例如：

```assembly
movq %rdi, %rbx
andl $1, %ebx
#ebx是rbx的低32位形式
#在与运算过程中只有rbx的低32位参与了运算
#以及立即数1在运算过程中也是32位，并且用0补全剩下的31位
```

5. 由4注意点可知寄存器e开头和r开头的区别就是寄存器空间是否为64位。
6. (寄存器)，例如：(%rax)表示取出以寄存器rax的值为主存访问地址的数据(通俗一点：将寄存器rax中的值作为地址，将主存上对应地址的数据取出来)。
7. 

### CISC

复杂指令集

设计思路:一条指令完成一个复杂的基本功能。

代表: x86架构，主要用于笔记本、台式机等


### RISC

精简指令集

设计思路:一条指令完成一个基本“动作”; 多条指令组合完成一个复杂的基本功能。

代表:ARM架构，主要用于手机、平板等

![image-20230708011622385](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708011622385.png)

#### 对比

![image-20230708011943294](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230708011943294.png)

### *题目

#### 求寻址范围：

![image-20230709121251211](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230709121251211.png)

由上图可知：

间接寻址的寻址范围，根据指令长度，可看出存储字长的大小得出数据块位数，即寻址范围为2^指令长度。

变址寻址的寻址范围，根据变址寄存器的位数，可计算出寻址范围为2^寄存器位数。

### *做题知识点考察总结

1. 在计算地址的时候，我们需要注意到其数值位十六进制(H)下。在对十进制数进行计算时，我们需要将十六进制数转换为十进制数。

2. 隐函数：隐地址不显示给出操作数的地址。

3. 对于存储器中：存储单元(存储字)、存储字长、存储字数、存储容量计算和知识点意义。

4. 数据寻址中：普通寻址、偏移寻址、堆栈寻址，**其有效地址(EA)如何求**。以及根据EA得到的**立即数应存放在ACC中**。

5. 寻址范围：
   1. 间接寻址的寻址范围：2^指令长度(数据块长度=存储字长，理解指令与数据同等地位存放在存储器中这句话)
   2. 变址寻址的寻址范围：2^IX寄存器位数^
   3. 基址寻址的寻址范围：2^BR寄存器位数^

6. 求偏移量取值范围：在基址寻址中，形式地址位数=偏移量位数。

7. 负数的补码计算。

8. 根据地址编制方式：大端法、小端法，求最高有效字节或最低有效字节地址。

9. 题中需要区分，访问地址和形式地址，因为在实际的存储器中，形式指令也是有对应的主存访问地址。

10. 对于内容的计算，可表示值会根据寄存器的宽度，进行截断。（比如：某一寄存器位宽为16位，其计算后结果为12345H，说明溢出，则高位截断。）

11. 对于给出的指令及其指令结构，做题时需要结合分析。
12. 机器码，就是将指令各部分的内容变为对应的二进制(操作码中不同指令的二进制编号不同，寄存器编号转为二进制)，然后将题目化为十六进制数即可。

### 本节二轮复习需要注意点：

对于两数的比较，各种情况下符号位的取值。

寻址范围的计算。

根据**真题的综合题型**（复习本章的综合题）。



# 输入/输出系统

## 基本点

### 驱动程序

用于将I/O接口向主存输出对应I/O设备命令码的I/O软件。

## I/O控制方式

#### 程序查询方式

CPU通过程序不断查询I/O设备的I/O接口中状态寄存器是否为已完成，来控制I/O设备。

#### 程序中断方式

I/O设备会在准备就绪时向CPU发出中断请求。而CPU在完成当前指令后给予响应。

#### DMA方式

主存和磁盘（具有传输率较高的辅存）之间有一条数据通路，无需调用中断程序。

#### 通道方式

即在主存和I/O设备之间配置一个小硬件（叫通道，是一个芯片）。每个通道挂接若干外设。在完成I/O命令时，只需启动有关通道，通道将执行通道程序，控制I/O接口完成I/O操作。

通道程序存放在主存之中。驱动程序用于解释对应设备的命令码。

##### I/O指令

![image-20230723111634912](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230723111634912.png)

I/O指令中，**操作码**用于指示出**CPU要对I/O接口**做什么，而**命令码**指明**I/O接口要对设备**做什么。

##### 通道指令

![image-20230723111716317](https://duuuuu17bucket.oss-cn-shenzhen.aliyuncs.com/img/image-20230723111716317.png)



#### 总结

CPU实际发出的是I/O指令，通道接收后，发出的是存储于主存中的通道指令。

其中程序查询方式和程序中断方式用于数据传输率较低的外部设备。

DMA方式和通道方式用于数据传输率较高的外部设备。

