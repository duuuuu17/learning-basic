# Theory of Data Structure

计算机所处理的数据一般具有某种内在联系，这是元素和元素之间存在某种关系。

在数据结构中，与计算机无关的是数据的逻辑结构。

要存储数据时，通常不仅要存储各数据元素值，还要存储数据元素之间的关系。

时间复杂度表示的是执行时间与其成正比。

算法原地工作是指辅助空间不随着数据规模的增大而增大,不是说不需要辅助空间。

### 时间复杂度

最根据嵌套（循环）有关：不单与数据规模有关，更有关于其数据初始状态和实际算法操作情况。

### 空间复杂度

![image-20221206193728154](C:\Users\w4737\Desktop\数据结构\picture\空间复杂度.png)

# 线性表

## 概念：

数据元素<u>个数有限</u>、<u>逻辑上具有顺序</u>、<u>数据元素类型相同</u>。

该数据结构<u>仅表示数据元素之间的关系</u>。

## 顺序表

逻辑结构与存储结构一致，访问每个元素所花时间相等。（随机存取法）

## Linked list

逻辑结构与存储结构不一致。访问每个元素所花时间不相等。（顺序存取法）

## 比较

![image-20221206195849981](C:\Users\w4737\Desktop\数据结构\picture\顺序表和链表的比较.png)

## Stack

## Queue

## 字符串

## 数组



# 非线性结构

## Tree

概念：

边、根结点、分支节点、叶子结点、

结点的层次：从上往下数，

结点的高度：从下往上数；

树的高度：总有多少层数；

结点的度：有几个连通分支；

树的度：各结点的度的最大值。

#### 主要讲二叉树

properties(性质)

1. 第i层的结点个数为:
   $$
   2^{ i-1}
   $$
2. 在任何树种，若有度为2的结点有$n_2$个，若度为1的结点有$n_1$个，度为0的结点有$n_0$个。有以下公式：
   $$
   已知:n_o = n_2 + 1\\总边数B=n-1=2*n_2+1*n_1 \Rightarrow n = 2n_2+n_1+1\\
   且又有n = n_2 +n_1+n_0\\
   $$

   

3. 深度(高度)为k的二叉树，其结点最多有2^k-1个，最少有k个结点。

4. 当二叉树的结点有n个时，其深度k为。(此处求的是树深度的最小值，最大值则每结点只有单个子树)
   $$
   \because\ 2^{k-1} -1\leq n\leq2^k -1\
   或者\ 2^{k-1} \leq n\leq 2^k(k\in height,结点值的区间表示)\\
   \therefore\ k-1\leq log_2n\leq k(选其k的max,能够满足该不等式)\\
   
   \therefore\ k= log_2n \ +1
   $$

#### 其他树

1. 最满二叉树，即每一层都满的（叶子结点在最底层），其左子树编号为2^i 右子数为2^ -1。

2. 对满二叉树结点位置进行编号。编号规则:从根结点开始，**自上而下，自左而右**。每一结点位置都有**元素**。

![image-20221022225346594](C:\Users\w4737\Desktop\数据结构\满二叉树.png)

$$
满二叉树 \rightarrow (\nleftarrow) 完全二叉树
$$

7. 完全二叉树，树最后一层，只有左子树。深度为k的具有n个结点的二叉树，当且仅当其每一个**结点**都**与**深度为k的满二叉树中编号为1~n的**结点一一对应**（即**连续对应**）时（也可从满二叉树尾结点连续去掉角度看）。

8. 完全二叉树性质：

​		1)叶子结点分布在最大两次层次上;

​		2)对于任意一节点，其左子树的最大层次=右子数的最大层次或者右子数的最大层次+1

​		3)若有节点编号为i，则其双亲节点为floor(i/2)向下取整，孩子节点：左孩子为2* i，右孩子为		2*i+1（顺序存储会使用）

#### 顺序存储

适用于满二叉和完全二叉树

在顺序存储结构中，最坏的情况下，深度为k的二叉树，只有k个节点，则浪费了2^k - k个节点。

#### 链式存储结构

##### 二叉链表(指针域为2)

n个结点的二叉链表，最多有n+1个空指针域
$$
\because 每个结点有两个指针域\\
\therefore 有2n个指针域\\
又\because 除开根结点，至少有n-1个结点有非空指针域\\
\therefore 最多有2n-(n-1) = n+1个空指针域
$$
<img src="C:\Users\w4737\Desktop\数据结构\链式存储1.png" alt="image-20221023001517054" style="zoom:80%;" />

##### 三叉链表(指针域为3，比二叉多一个指向前驱的指针域)

除了根结点没有前驱，其余都有。

<img src="C:\Users\w4737\Desktop\数据结构\链式存储三叉.png" alt="image-20221023002400778" style="zoom:80%;" />

#### 树的遍历

##### 前序遍历DLR

先访问结点值，再访问左结点，最后访问右结点。

##### 中序遍历LDR

先访问左结点，再访问结点值，最后访问右结点。

##### 后序遍历LRD

先访问左结点，再访问右结点，最后访问结点值。

三种遍历访问路径相同，只是访问时机不同。

![image-20221023130435312](C:\Users\w4737\Desktop\数据结构\二叉树遍历.png)

##### 层序遍历

使用两个队列，一个存储子结点地址，一个存储结点值

先访问root，然后访问他的lchild和rchild入队，如果lchild不为空，入队，并出队头结点，然后访问rchild不为空，入队其子结点,并出队头结点。

##### 二叉树应用
<font color="#dd0000">如何将数学模型转换为程序模型</font><br />

<font color="#006600">解决问题时，利用递归思想，**可将二叉树划分许多个小的二叉树**，从而得出的停止递归条件，和递归时所需操作。</font><br /> 

###### 复制

<img src="C:\Users\w4737\Desktop\数据结构\二叉树复制.png" alt="image-20221023160022804" style="zoom:50%;" />

###### 深度

<div align=left>
<img src="C:\Users\w4737\Desktop\数据结构\二叉树的深度.png" alt="image-20221023160132464" style="zoom:50%;"/>
<img src="C:\Users\w4737\Desktop\数据结构\二叉树图像.png" alt="image-20221023160132464" style="zoom:50%;"/>
</div>
###### 结点数

![image-20221023161152337](C:\Users\w4737\AppData\Roaming\Typora\typora-user-images\image-20221023161152337.png)

###### 叶子结点

<img src="C:\Users\w4737\Desktop\数据结构\求叶子结点.png" alt="image-20221023162310620" style="zoom: 80%;" />



#### 哈夫曼树

是二叉树的应用，它的编码场景：先将元素集的元素按权值排序，再将最小权值的两个元素构造最底层二叉树，依次在元素集中的字符中找权值与之比较为小或大的一项，做其子树结点层的左子树或右子数。**左小又大，左0右1。**

<img src="C:\Users\w4737\Desktop\数据结构\哈夫曼树构成图解.png" alt="image-20221023105428416" style="zoom: 67%;" />



### 带权路径长度WPL

#### 1.通过叶子结点计算

$WPL_总=\sum叶子结点权值*所在层数$

2.通过数学思维，将所有子树节点相加

$WPL_总=\sum除层数1的根结点外，其余所有结点权值新加$

#### 线索二叉树

1. 利用二叉链表的空指针域

##### 定义：

“线索”，若结点的左孩子为空，则其左指针指向其前驱；若结点的右孩子为空，则其右指针指向后继。 

其前驱后继的关系，利用先、中、后遍历可知。

![image-20221023182335946](C:\Users\w4737\Desktop\数据结构\线索二叉树tag.png)

![image-20221023183035712](C:\Users\w4737\Desktop\数据结构\线索二叉树的头结点.png)

![image-20230226095333997](.\picture\线索二叉树构建之中序序列.png)



##### 树的存储结构

![image-20221023190057450](C:\Users\w4737\Desktop\数据结构\树的存储结构1.png)

![image-20221023190720862](C:\Users\w4737\Desktop\数据结构\孩子链表.png)

![image-20221023191222426](C:\Users\w4737\Desktop\数据结构\孩子链表2.png)

![image-20221023192458953](C:\Users\w4737\Desktop\数据结构\兄弟孩子链表.png)

左长子，右兄弟。





## Forest

<img src="C:\Users\w4737\Desktop\数据结构\树和森林.png" alt="image-20221023185809274" style="zoom:80%;" />

### 树与二叉树的转换

**左长子，右兄弟。**

![image-20221023192915368](C:\Users\w4737\Desktop\数据结构\森林转二叉树.png)

![image-20221023193142272](C:\Users\w4737\Desktop\数据结构\森林转二叉树图解.png)

加线：兄弟之间加一条线；抹线：每个结点除了左孩子的连线，其余为孩子之间连线；旋转：以树的根结点为轴心，将整个树顺时针转45°。	

##### 二叉树转树：

即左孩子的右边兄弟，连双亲，去掉兄弟连线，并转向即可。

二叉树变树:左孩右右连双亲，去掉原来右孩线。

树可以找到唯一的二叉树。

#### 森林与二叉树的转化

##### 森林变二叉：

先森林转二叉树，树变二叉根相连。

<img src="C:\Users\w4737\Desktop\数据结构\森林转二叉.png" alt="image-20221023195936987" style="zoom:80%;" />

##### 二叉树变森林:

去掉全部右孩线，孤立二叉再还原。

#### 森林的遍历：

![image-20221023201552939](C:\Users\w4737\Desktop\数据结构\森林遍历.png)

从左往右依次从每个树中先根遍历。



## Graph

| vertex[]顶点             |                                                              | edge[]邻边，无向：（x,y）有向：<x,y> |                                                              |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------ | :----------------------------------------------------------- |
| 无向图的总度数           | =$总边数\times2$                                             | 有向图的度                           | (入度：顶点被作为目标顶点、出度：顶点被作为起始顶点)         |
| 连通图                   | (即任意两个顶点间都有路径可达)                               | 强连通图                             | 即在有向图也存在这种情况                                     |
| 连通分量（极大连通子图） | （即最小连通图,若其加入其他顶点(该顶点属于父图中)会有顶点无法连通) | 强连通分量（极大强连通子图）         | 即在有向图也存在这种情况                                     |
| 极小连通子图             | 子图删除任意一边，该图不再连通                               |                                      |                                                              |
| 生成树                   | 包含无向图G所有顶点的极小连通子图                            | 生成森林                             | 对于非连通图，其各个连通分量的生成树的集合                   |
| 子图                     | 其图中的顶点属于父图顶点(其本身也为子图)                     | 带权图                               | 即领边有权值，也叫网图                                       |
| 路径                     | 连续的边构成的有起始顶点和目标顶点的顶点序列                 | 路径长度                             | 即路径上无权图中：边的数目之和；带权图中：连续边的权值之和。 |
| 稀疏图                   | 弧边较少的图                                                 | 稠密图                               | 弧边较多的图                                                 |

无向图的边数最多$[n\times(n-1)]/2$     有向图的边数最多$[n\times (n-1) ]/2$



<img src="C:\Users\w4737\Desktop\数据结构\连通图1.png" alt="mmexporta0cdaa70fd7ba8634bfd9320fc7b2782_1667040" style="zoom: 50%;" />

<img src="C:\Users\w4737\Desktop\数据结构\连通图2.png" alt="mmexport3c6db6b7298ef3475d7442154e4476ff_1667040" style="zoom:50%;" />

![image-20230226134036355](C:\Users\w4737\Desktop\数据结构\picture\生成森林.png)

无向图的邻接矩阵是对称的，有向图的邻接矩阵是无规则的。

无向图的度，在邻接矩阵中，若以行标为图中顶点，其度为所在行的所有邻边之和。(如：下表，顶点1的度为所在行的邻边总数--2)

|      | 1    | 2    | 3    |
| ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    |
| 2    | 1    | 0    | 1    |
| 3    | 0    | 1    | 0    |

​																						邻接矩阵  表4-1

有向图的度，其出度=在所在行的邻边数之和，入度=为顶点所在列的相邻顶点数之和。（如：上表，顶点1的出度为2，入度为1）

<img src=".\最小生成树.png" alt="image-20221108190254448" style="zoom:80%;" align="left"/>

BFS的邻接表访问结点，是依次访问同层未访问节点。

<font color=red>同一个图的邻接矩阵表示方法唯一，因此BFS序列唯一</font>

<font color=red>同一个图的邻接表表示方法不唯一，因此BFS序列不唯一</font>，但是出发点肯定是依次访问邻接点的。



### 最小生成树

具有n个顶点，m=n-1条边

#### 最小生成树的生成算法

<font color="red">找出n-1条边停止</font>

##### 普里姆算法

属于归并顶点集，看出发顶点到下一顶点的权值最近距离，就是下一个。

##### 克鲁斯卡尔算法

属于归并边集，循环找一条的权值最小，但要避免出现回环，最后连接。

### 最短路径

#### BFS

类似于树的层序遍历，使用两个队列，一个保存下一个读取的层序顺序的顶点队列node，一个是路径打印顶点遍历path。

#### Dijkstra迪杰斯特拉算法

##### 参数

使用三个list

| final[]当前顶点是否已确定最短路径 | $[x_n\in[true,false]]$                                       |
| --------------------------------- | ------------------------------------------------------------ |
| 对应顶点的最短路径dist[]          | $[weights.sum(start,now\_node)]$即存放的是从出发点到下一个邻点的权值，如果小于或本身无记录，则更新dist对应的路径值（权值）和path中它的前驱，否则不更新 |
| 前驱顶点path[]                    | 记录对应顶点最短路径的前驱顶点                               |

##### 初始化

先访问出发点的所有直接邻点，并更新其对应的dist中的值，和前驱path的值，若是间接，则都为-1，所有的确认最短路径的final除了出发点为true其余为false。

时间复杂度为$O(n^2)$

##### 算法过程描述

先初始化，即从出发点开始找邻点的路径，并决定是否更新dist，找当前所有dist最小的path，并更新它的final为true（即已有最短路径），然后再把这个path的尾点作为出发点，然后循环如此操作，直至到所有顶点被遍历。（可结合有向图示看）

##### 无向图

![image-20221108191239790](.\dijkstra算法过程图示.png)



##### 有向图

![image-20221108193522537](.\dijkstra算法过程图示有向图.png)



迪杰斯特拉算法只适合权值为正的数

#### floyd算法

每个顶点都迭代n-1次，即暴力穷举，从出发点到终止点，其中的每个邻近经过点依次选取构造一个path从而完成，时间复杂度为$O(n^2)$

### 拓扑排序

通俗来说，就是根据事件的进行流程，构建的一个具体实施步骤顺序。

#### AOV网：（用顶点表示活动）

用顶点表示事件，用有向边表示活动的先后关系，且为有向无环图(DAG)。

**若有环**，则有关该部分的顶点无法被遍历。

```c++
（在编程时，引用一个count变量，最后count <G.vecnum ? false : true;)
```



##### 实现过程：

1.选择入度为0的顶点$v_i$。

2.选择$v_i$后，需要先将以它为起始点的有向边（$v_i$所对应的出度）从图中删除并更新图的出入度记录，然后输出并在图中删掉该顶点。

3.依次反复。直至图中无顶点。

![拓扑排序过程](.\拓扑排序过程.png)

**需要注意的是，因为入度为0的顶点，同一时间下，可能有多个，所以最终的拓扑排序不唯一。**

###  逆拓扑排序

就是拓扑排序的逆输出即可，它的过程实现就先找出度为0的顶点。

### 关键路径：

**工程中最长的路径叫关键路径，关键路径上的活动叫关键活动。**

如果关键活动不能按时完成，工程将被破延期。

为了不延误，工程所需时间为关键路径。

**事件最早发生时间**：按拓扑排序的顺序计算。

**事件最晚发生时间**：按逆拓扑排序的顺序计算。

每个同层级事件可以同步完成。 

#### AOE网：（用边表示活动）

用顶点表示事件，边表示完成事件所需的开销。有向无环图DAG。

##### 思维

| 有源点（入度为0）有终点（出度为0）                           | 只有在活动到达该某事件，表示某事件所代表的活动才开始（即某顶点的出边的开销才开始计算） |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 只有在指向某顶点的其余的指向活动边全部结束后，才表示该顶点的活动开始发生 | AOE网中，有些活动可以同时进行。                              |

如图：

![AOE网的特点](C:\Users\w4737\Desktop\数据结构\AOE网的特点.png)

![mmexport1667910356811](C:\Users\w4737\Desktop\数据结构\AOE网事件.jpg)

##### 牢记

只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始

只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始

##### 例题：

![image-20221109195010982](.\AOE例题.png)

| 事件的最早发生时间 | 按拓扑排序的顺序计算到该点的关键路径，获得关键路径总长(27)   |
| ------------------ | ------------------------------------------------------------ |
| 事件的最迟发生时间 | 按逆拓扑排序的顺序计算，由已知的关键路径总长，减去事件开销时间(4:27-6=21) |
| 活动最早开始时间   | 按活动所属的起点事件的最早发生时间(g(事件4):=19)             |
| 活动最晚开始时间   | 按活动(前驱)指向事件(后驱)的最晚发生时间减去该活动开销(g:27-6=21) |
| 活动余量           | 即活动最晚开始时间-最早开始时间                              |

##### 事件(活动)的最早(晚)发生(开始)意思的解读：

| 事件的最早发生时间 | 因为事件发生的特点，所以当所有进入该事件前的所有活动结束，就立即开始 |
| ------------------ | ------------------------------------------------------------ |
| 事件的最迟发生时间 | 也就是经过该事件，下一个事件发生的开始所需开销-该事件开销。 |
| 活动最早开始时间   | 也就是到某活动前的所有前置活动，就立即开始              |
| 活动最晚开始时间   | 也就是该活动指向的事件的最晚开始时间-此活动的开销         |

<img src=".\数据结构知识点图.png" alt="image-20221115193910538" style="zoom:50%;" align="left"/>

# 查找

在数据集合中查找满足条件的数据元素的过程，称为查找。

## 顺序查找

### 查找表

用于查找的数据集合（由同一数据类型记录/组成。

#### 关键字

数据元素中唯一标识该元素的某项值。类似于数据库的关键字。

#### 主关键字

关键字可以**唯一**地标识一个记录

#### 次关键字

用以识别**若干**记录的关键字。

### 对查找表操作

#### 静态查找表

仅关注查找速度

#### 动态查找表

除了查找速度，也要关注插/删操作是否方便。

### 查找算法的评价指标

#### 查找长度

需要**对比关键字次数**的称为查找长度。

#### 平均查找长度ASL(average search length)

**所有查找过程**中进行关键字的**比较次数的平均值**。

$ASL=\sum^n_{i=1}P_iC_i$ ，若题目没有表示，默认每个元素查找概率相同。

**n表示的数据元素个数，P表示查找第i个元素的概率，C表示查找第i个元素的查找长度。**

ASL的数量级反映了查找算法时间复杂度。

#### 区分：

查找成功时的ASL

查找失败的ASL

### 顺序查找

从头到尾，从尾到头查找。

适用于顺序表、链表，且与表中元素是否有序无关。

**时间复杂度都为O(n)。**

#### 哨兵模式查找

在数组下标0处加入需要查找元素，并从尾到头进行查找，其无需判断下标是否越界问题。

![image-20221116211040776](C:\Users\w4737\Desktop\数据结构\picture\顺序查找哨兵版.png)

#### 将数组元素有序排列

若能找到关键字，比无序要快。优点：使查找失败时ASL更小。（解释：当要查找关键字在查找表中直到对应查找元素**a[i]--success或 key <a[i]**比他大就停止(循环条件key>a[i])

#### 查找判定树

在题目无叙述概率时，其默认失败和成功等概率发生。

**成功结点的查找长度=自身所在层数**，**成功查找的ASL=每个成功结点的查找长度之和**

**失败结点的查找长度=父节点所在层数**，**失败查找的ASL=每个失败结点的查找长度之和**

<img src=".\picture\使用查找判定树写ASL.png" alt="image-20221116211448292" style="zoom:80%;" />

#### 关键字不等概率查找

可按被查找概率进行降序排序。优点：是查找成功的ASL更小。

<img src=".\picture\不等概率顺序查找.png" alt="image-20221116211713294" style="zoom:80%;" />

### 折半查找

仅适用于有序的顺序表。

动态区间[low,high]，根据key与mid的比较设定。$mid= \frac {low+high}{2}$，根据题目要求向下或向上取整，默认向下取整。

#### 在升序顺序表中

当key比mid大时，low = mid +1,即下届下标于上一区间mid的右边。

当key比mid小时，high = mid - 1，即上届下标位于下一区间mid的左边。

在降序顺序表中 对应对上下界操作相反。

#### 在降序顺序表中

当key比mid大时， high = mid -1,即上届下标位于下一区间mid的左边。

当key比mid小时，low = mid + 1，即下届下标于上一区间mid的右边。

#### 注意

**循环条件low < high，当下届大于上界，即查找失败。**

#### 查找效率分析

通过mid进行二分为二叉树型，写出$ASL_{成功}和ASL_{失败}$

<img src=".\picture\二分查找效率分析.png" alt="image-20221116220248466" style="zoom:80%;" />

#### 折半查找判定树的构造

<img src="C:\Users\w4737\Desktop\数据结构\picture\折半查找判定树的构造.png" alt="image-20221116220920710" style="zoom:80%;" />

#####  练习：

**（此处mid向下取整）**

<img src=".\picture\折半查找判定树的构造习题1.png" alt="image-20221116221334622" style="zoom:80%;" />

**（此处mid向上取整）**

$mid= \frac {low+high}{2}$，则对于任何一个节点，必有：左子树结点-右子数结点=0或1

<img src=".\picture\折半查找判定树的构造习题2.png" alt="image-20221116223639936" style="zoom:80%;" />

折半查找判定树一定是**平衡二叉树，且最底层是不满的，其树高h=$log_2(n+1)$**,

##### 特性

满足二叉排序树（$节点值:左\lt中\lt右$）

失败结点（叶子结点）：$n_o=n_2+1$，等于成功节点的空链域（左右子树为NULL）之和。

解释：在二叉树的性质中，空链域个数=节点个数+1

$查找成功的ASL\leq h ,当n过大时，ASL_{成功}=log_2(n+1)-1 $

$查找失败的ASL \leq h$

$ 折半查找的时间复杂度=O(log_2n)$

#### 注意：

在大部分情况下，折半查找的效率高于顺序查找。但并不是折半查找完全优于顺序查找。

### 分块查找

又称索引顺序查找，其结构为：

| 块1最大关键字 | 块2最大关键字 | 块n最大关键字 |
| ------------- | ------------- | ------------- |
| 块1地址       | 块2地址       | 块n地址       |



## 数表的查找

### 二叉排序树

左子树全都小于根结点，右子数全都大于根结点。

#### 特征：

左子树<根结点<右子树

### 平衡二叉树

其平衡二叉树，就是在二叉排序树的基础上再加了一个限制，**即父结点左子树的高度-右子树的高度之差的绝对值不超过1。**

#### 平衡化旋转

每次调整都是从“**最小不平衡子树(需要先找到不平衡因子出现的结点处)**”进行。其目的是为了：保持平衡；保持二叉排序树的特征。将树高度恢复原状。

##### 做题时：

1.先确定最小不平衡子树

2.确定多余结点旋转平衡属于类型

3.实施平衡方案

##### 单旋转：

###### LL：左单旋转

父结点的左孩子的左子树中插入导致不平衡。<u>左孩子右旋</u>。

###### 解决：

​	将最小不平衡子树的根结点进行顺时针旋转——将其子树的根结点A向**右下旋转**，使它A原本的左孩子B变为根结点代替它，为了新结构也满足平衡二叉树，其根结点B的右孩子BR，应在它的右孩子A，且为左子树AL(原本为BR)。

**或者说：根结点A的左孩子B右上旋。**

![image-20221122235452668](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树(LL).png)

###### RR:右单旋转

父结点的右孩子的右子树中插入导致不平衡

###### 解决：

是LL每步骤的相反方向；<u>右孩子左旋。</u>

​	将最小不平衡子树的根结点进行逆时针旋转——将其子树的根结点B向**左上旋转**，使它B原本的右孩子A变为根结点代替它，为了新结构也满足平衡二叉树，其根结点A的左孩子AL，应在它的左孩子B，且为左子树BL(原本为AL)。

**或者说：根结点A的右孩子B左上旋。**

![image-20221123000938496](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树(RR).png)

##### 双旋转：

###### LR:左右双旋

父结点的左孩子的右子树中插入导致不平衡，**孙子左旋，儿子右旋**

###### 解决：

先选取最小不平衡子树，并将其左子树B（也就是包含导致不平衡的结点的左子树)，将其向**左上旋转（位置由C到B）**。然后再由向**右上旋转(位置由C到A)**。从而完成左右双旋转。

![image-20221123002951592](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树(LR).png)

![image-20221123003959496](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树(LR2).png)

**多余结点在C的左子树，则最终在B结点的右子树；多余结点在C的右子树，则最终在A结点的左子树**

###### RL:右左双旋

父结点的右孩子的左子树中插入导致不平衡，**孙子右旋，儿子左旋**

###### 解决：

先选取最小不平衡子树，并将其右子树B（也就是包含导致不平衡的结点的左子树)，将其向**右上旋转（位置由C到B）**。然后再由向**左上旋转(位置由C到A)**。从而完成右左双旋转。

![image-20221123004623281](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树(RL).png)

![image-20221123004710484](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树(RL2).png)

**多余结点在C的右子树，则最终在B结点的左子树；多余结点在C的左子树，则最终在B结点的右子树**

##### 注意：

在旋转操作中：

1）当不平衡子树为树的本身时，那么在最终旋转后的树中，其根结点为原多余结点的父结点，而该父结点的左子树在它的父结点的右子树中，而它的右子树，在原它的根结点的左子树中。

2）当不平衡子树为树的某个子树A时，找到与多余结点最近的父结点B，然后其左子树为它父结点A的右子树，而它的右子树若右边无结点，则不变（若有则为右边结点的左子树)。

![image-20221123011215767](C:\Users\w4737\Desktop\数据结构\picture\双旋转练习题.png)

##### 查找效率ASL=$log_2n$

高度为h的平衡二叉树至少有多少个结点。$h = log_2n \rightarrow 2^h \ge n \ge 2^{h-1}$。

#### 删除操作

在删除一个结点后，仍需保持二叉排序树的特性(左<中<右)；以及平衡二叉树的子树高度差不超过一的特性。

 

![image-20221123014438548](C:\Users\w4737\Desktop\数据结构\picture\二叉排序树的删除.png)

##### 步骤

<img src="C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树的删除操作步骤.png" alt="image-20221123014918445" style="zoom:90%;" align="left"/>

当删除的是中间结点（即有左右子树）时，如图：

![image-20221123020320396](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树的删除操作步骤1.png)

#### 考点

![image-20221123021128219](C:\Users\w4737\Desktop\数据结构\picture\平衡二叉树的考点.png)

##  散列表(又称哈希表)

#### 特点

其关键字与其存储地址直接相关。(H(key) = key mod num)

##### 同义词

不同的关键字通过三列函数映射到同一个值。

##### 冲突

当一个关键字存入散列表时，其对应存储位置已经有值，则我们称之为冲突。

### 处理冲突的方法

#### 链接法(链表法) 重点

使用单链表处理冲突：即是把mod运算后的关键字存放在一起在同一个地址。

##### 优化

将单链表的序列变为有序。

![image-20221126202117253](C:\Users\w4737\Desktop\数据结构\picture\hash链表法.png)

##### 查找

查找每个元素先进行取模运算后，找到其地址，然后再依次比较key值的次数，得出该元素的查找长度。

通过以此可计算整个链表法的ASL=$\sum^n_{i=1}元素_i的查找长度$

###### 注意

当**比较的地址为空指针时**，查看往年考试情况来看，**默认为查找长度(次数)为0**。就算该单链无该key值，其查找长度为单链长度即可。

##### ASL

![image-20221126203505394](C:\Users\w4737\Desktop\数据结构\picture\hash链表法ASL.png)

如上图$ASL_{失败}=\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{12}=0.92$

<font color="red">装填因子=</font>$ASL_{失败}=对应地址存有记录数/散列表长度$

装填因子反映了散列表的查找效率



#### 开放定址法

![image-20221126210514247](C:\Users\w4737\Desktop\数据结构\picture\hash链表法的开放地址法.png)



###### <font color="red">线性探测法</font> 重点

###### <font color="blue">插入</font>

![image-20221126211249042](C:\Users\w4737\Desktop\数据结构\picture\线性探测法.png)、

![image-20221126212148898](C:\Users\w4737\Desktop\数据结构\picture\线性探测法的值域.png)

###### <font color="blue">查找长度</font>

先计算关键字取模后地址$H_0$，此时次数为1，若有冲突，则再加上线性探测的长度(即往后比较的次数)。

###### <font color="blue">删除</font>

当删除一个元素时，不能单纯将其在散列表中删除，**还需要使用辅助数组，逻辑标注它已删除**，否则后续元素查找时，会提前结束(查找异常)。

###### ASL

$ASL_{成功}=计算每一个元素的查找长度/散列表元素长度$

$ASL_{失败}=计算每一个元素的查找失败的长度/散列表元素长度(当某元素为空，则它只找一次)$

![image-20221126213544795](C:\Users\w4737\Desktop\数据结构\picture\线性探测法ASL_fail.png)

###### <font color="red">平方探测法</font>

解决同义词和非同义词聚集问题。

**i为关键字除余后的余数，当做下标。**

![image-20221126213933515](C:\Users\w4737\Desktop\数据结构\picture\平方探测法.png)



###### 非重点小坑:

散列表长度m必须是一个可以表示成4j+3的素数，才能探测到所有位置





###### <font color="red">伪随机序列法</font>

$d_i递增序列为随机数$

#### 多重散列表法

使用多张散列表存储关键字，用空间换时间。 

### 常见的构造方法

<font color="red"><u>以下结构都是为了减少关键字冲突，并不代表没有冲突。</u></font>

#### 除留取余数法



![image-20221126204210276](C:\Users\w4737\Desktop\数据结构\picture\hash链表法的除留取余数法.png)

用质数取模，分布耿军，冲突更少。



#### 直接定址法

![image-20221126204630831](C:\Users\w4737\Desktop\数据结构\picture\hash链表法直接定制法.png)

#### 数字分析法

<font color="red">利用分布均匀的数码为关键字</font>

![image-20221126205508482](.\picture\hash链表法的数字分析法.png)

#### 平方取中法

实际也是利用均匀分布数码做关键字。

![image-20221126205152101](.\picture\hash链表法的平方取中法.png)

### 单元小总结

![image-20221126214922575](.\picture\hash_conclusion.png)

## B树

所有叶子结点在同一层，其类似于2-3数

## B+树

![image-20230323163503613](./picture/B+树结构.png)

# 排序

### 稳定的

<font color="red">关键字相同的元素在排序之后相对位置不变。</font>

### 内部排序和外部排序

内部排序：其数据都在内存中，需要关注如何使算法的时间、空间复杂度低。

外部排序：数据太多，无法全部放入内存，需要关注如何使读/写磁盘次数更少。

## 插入排序

是将未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已排序序列的正确位置。

#### 直接插入排序

![image-20221129222201147](C:\Users\w4737\Desktop\数据结构\picture\直接插入排序.png)

时间复杂度$O(n*(n-1))=O(n\backsim n^2)$

空间复杂度$O(1)$

是稳定的算法

### 折半查找

![image-20221129222809554](C:\Users\w4737\Desktop\数据结构\picture\折半查找代码.png)

### 总结

![image-20221129225035010](C:\Users\w4737\Desktop\数据结构\picture\插入排序总结.png)

## 希尔排序

### 特点

利用增量$d_n$,将基本有序数据进行分组排序，$d_1=\frac{n}{2},d_2=d_1/2,直到d小于1停止$

利用增量分组后，每组之间进行数据比较和交换。比如：

即在长度8的数据序列中，第一次分为两组，从下标1开始，利用d+1搜索同组元素进行比较。

![image-20221129191814187](C:\Users\w4737\Desktop\数据结构\picture\希尔排序.png)

**仅适用于顺序表**

### 总结

![image-20221129192145082](C:\Users\w4737\Desktop\数据结构\picture\希尔排序总结.png)

### 希尔排序代码

![image-20221129192305284](C:\Users\w4737\Desktop\数据结构\picture\希尔排序代码.png)

## 交换排序

两两比较且交换,即每一趟终会将未排序序列中最大或最小元素放置有序序列的首位。

### 冒泡排序

#### 特点

遵照“前小后大”的规则进行两两比较。<font color="red">待排序序列中元素最大(小)的数放置最后。</font>下一次不再参与比较。

总共需要比较9次最大值出来(最外层)，内层逐步比较(除去以排序的好最大值(10-i)个数)

#### 优化

加个flag，当数据序列已有序，则跳出不再比较。

时间复杂度为O(n-1~ $n^2$),空间复杂度为O(1)

#### 总结

![image-20221129221723637](C:\Users\w4737\Desktop\数据结构\picture\冒泡总结.png)

## 快速排序

### 算法思想:

在待排序表L[1..n]中任取一个元素pivot作为枢轴（或基准，通常取首元素)，通过一趟排序将待排序表划分为独立的两部分L[1..k-1]和L[k+1..n]，使得L[1..k-1]中的所有元素小于pivot，L[k+1..n]中的所有元素大于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。

当high所指的元素比pivot元素大，则high指针--移动，否则跳出，将low指针的元素赋予当前high指针值。

当low=high,确定基准元素位置。

### 代码

![image-20221129203255061](C:\Users\w4737\Desktop\数据结构\picture\快速排序代码.png)

### 时间复杂度

时间复杂度O($nlog_2n$)，就平均计算时间是所有内排序方法中最快的O(n*递归层数)

最坏情况下O($n^2/2$)，<font color="red">原本数据序列是有序或逆序的</font>

### 空间复杂度

O($log_2n$)，O(递归层数)

### 效率不同性

若每一次选中的“枢轴”将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高.(数据序列全无序)

若每一次选中的“枢轴”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低.(数据序列有序)

### 优化

快速排序算法优化思路︰尽量选择可以把数据中分的枢轴元素。
eg: ①选头、中、尾三个位置的元素，取中间值作为枢元素;②道机选一个元素作为枢轴元素

### 总结

![image-20221129215749983](C:\Users\w4737\Desktop\数据结构\picture\快速排序总结.png)

## 选择排序

将每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子列。

### 简单选择排序

#### 定义

选择待排序序列中最大(小)元素，插入至当前外层（有序序列）索引位置。

```python
temp = a[k]; 

a[k] = a[i];

a[i] = temp;
```

#### 效率分析

时间复杂度$O(\frac{n*(n-1)}{2})$ ,空间复杂度为$O(1)$.

树形选择排序，比普通选择排序要少一半时间复杂度。

### 堆排序

#### 定义：

若n个关键字序列L[ 1...n]满足下面某一条性质，则称为堆(Heap) :

若满足: L(i)≥L(2i)且L(i)≥L(2i+1) (1 ≤i <n/2 ) —(大根堆)(大根堆)

若满足: L(i)≤L(2i)且L(i)≤L(2i+1) (1 ≤i <n/2 ) ―小根堆(小根堆)

<font color="red">利用完全二叉树的顺序存储思考,其满足大/小根堆的数据序列</font>

#### 建立大根堆：

![image-20221130113944197](C:\Users\w4737\Desktop\数据结构\picture\大根堆.png)

![image-20221130115202581](C:\Users\w4737\Desktop\数据结构\picture\大根堆代码.png)

#### 进行排序

大根堆，每次选取最大元素加入有序子序列

小根堆，每次选取最小元素加入有序子序列

![image-20221130115528427](C:\Users\w4737\Desktop\数据结构\picture\大根堆排序.png)

小根堆的堆排序得到的是递减序列。

#### 算法效率

初始建堆的效率：$O(n)$

![image-20221130122438110](C:\Users\w4737\Desktop\数据结构\picture\初始堆的时间复杂度.png)

排序堆$O(nlog_2n)$

堆的时间复杂度：初始建堆的效率$O(n)+O(nlog_2n)=O(nlog_2n)$

![image-20221130120319318](C:\Users\w4737\Desktop\数据结构\picture\堆的算法效率.png)

空间复杂度O(1)

#### 插入和删除

##### 插入

将节点放入序列最尾端

##### 删除

若删除的不是堆最底元素，而是分支结点则需要用堆底元素（也就是序列元素尾端元素）进行替换，然后开始判断是否满足大/小根堆的要求，若不满足，则进行交换位置。最终使其满足要求。

#### 总结

![image-20221130123031221](C:\Users\w4737\Desktop\数据结构\picture\堆插入和删除的总结.png)

# 归并排序

## 定义

利用递归，从最开始归并长度i为1~$\frac{n}{2}$，也就是归并趟数。每一个归并前每一个部分数据序列是有序的，然后归并。

将多个有序序列合并成一个。

2路归并，即两个有序序列合并成一个有序序列。

四路归并，即四个有序序列合并成一个有序序列。

## 过程

![image-20221202151050373](C:\Users\w4737\Desktop\数据结构\picture\归并排序过程.png)

## 代码

![image-20221202152506438](C:\Users\w4737\Desktop\数据结构\picture\归并排序代码.png)



## 效率分析

![image-20221202184431412](C:\Users\w4737\Desktop\数据结构\picture\归并排序的效率分析.png)



## 总结

![image-20221202184738769](C:\Users\w4737\Desktop\数据结构\picture\归并排序总结.png)



# 基数排序

## 定义

分析题意，根据所给数据序列的关键字，创建d个辅助队列（因为关键字有可能不单单是数字，有可能是日期等等多元数据），并且每个辅助队列有相应的基数，根据题意，将数据序列的元素，按基数的升序还是降序排序，进行入队，然后进行出队链接为单链，依次往复直至第d个辅助队列。

![image-20221204140105888](C:\Users\w4737\Desktop\数据结构\picture\基数排序.png)

d元组，即关键字有多少位数（图示关键字为3元组，百位十位个位）。

最高位关键字：百位，最低为关键字：个位。

排序方式：最高位优先排序、最低为优先排序

## 效率分析

空间O（r）,时间O(d(n+r))

##  总结

![image-20221204141717955](C:\Users\w4737\Desktop\数据结构\picture\基数排序总结.png)

# 排序算法效率总结

![image-20221206190959005](C:\Users\w4737\Desktop\数据结构\picture\排序算法效率总结.png)
